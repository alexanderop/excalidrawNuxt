<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arrow Tool Walkthrough</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
    ></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              wt: {
                bg: "#000000",
                surface: "#0a0a0a",
                raised: "#141414",
                border: "#2a2a2a",
                fg: "#ffffff",
                muted: "#a0a0a0",
                accent: "#a855f7",
                file: "#c084fc",
                red: "#ef4444",
              },
              node: {
                component: "#a855f7",
                composable: "#7c3aed",
                utility: "#6d28d9",
                external: "#525252",
                event: "#d8b4fe",
                data: "#9333ea",
              },
            },
          },
        },
      };
    </script>
    <style>
      .mermaid-wrap svg {
        max-width: none !important;
        height: auto !important;
      }
      .mermaid-wrap .node {
        cursor: pointer;
      }
      .mermaid-wrap .node:hover rect,
      .mermaid-wrap .node:hover polygon,
      .mermaid-wrap .node:hover circle,
      .mermaid-wrap .node:hover .label-container {
        filter: brightness(1.3);
        transition: filter 0.15s;
      }
      .dt-body h3 {
        font-size: 0.95rem;
        font-weight: 700;
        color: #ffffff;
        margin: 20px 0 8px;
      }
      .dt-body h3:first-child {
        margin-top: 0;
      }
      .dt-body p {
        color: #a0a0a0;
        font-size: 0.88rem;
        line-height: 1.65;
        margin-bottom: 10px;
      }
      .dt-body ul {
        color: #a0a0a0;
        font-size: 0.88rem;
        line-height: 1.65;
        margin: 0 0 12px;
        padding-left: 18px;
      }
      .dt-body li {
        margin-bottom: 4px;
      }
      .dt-body li code,
      .dt-body p code {
        background: rgba(168, 85, 247, 0.12);
        padding: 1px 6px;
        border-radius: 4px;
        font-family: "SF Mono", "Fira Code", monospace;
        font-size: 0.82rem;
        color: #c084fc;
      }
      .dt-body pre {
        background: #000000;
        border: 1px solid #2a2a2a;
        border-radius: 8px;
        padding: 14px 16px;
        overflow-x: auto;
        margin: 8px 0 14px;
      }
      .dt-body pre code {
        font-family: "SF Mono", "Fira Code", monospace;
        font-size: 0.78rem;
        line-height: 1.55;
        color: #e0e0e0;
        background: none;
        padding: 0;
        border-radius: 0;
      }
    </style>
  </head>
  <body class="bg-wt-bg text-wt-fg m-0 overflow-hidden">
    <div id="root"></div>
    <script type="text/babel">
      var { useState, useEffect, useRef, useCallback } = React;

      var DIAGRAM =
        "graph TD\n" +
        '  subgraph activation["Tool Activation"]\n' +
        '    toolbarButton["DrawingToolbar\\nArrow Button"]\n' +
        '    toolIcon["Arrow Icon SVG"]\n' +
        '    useTool["useTool()\\nactiveTool ref"]\n' +
        '    toolTypes["ToolType / LinearToolType\\nType Guards"]\n' +
        "  end\n" +
        "\n" +
        '  subgraph creation["Element Creation"]\n' +
        '    createElement["createElement()\\nArrow Factory"]\n' +
        '    arrowType["ExcalidrawArrowElement\\nInterface"]\n' +
        '    arrowheadType["ArrowheadType\\narrow | triangle | none"]\n' +
        '    pointType["Point { x, y }\\ncreatePoint()"]\n' +
        '    mutateElement["mutateElement()\\nVersion Bump"]\n' +
        "  end\n" +
        "\n" +
        '  subgraph drawing["Drawing Interaction"]\n' +
        '    pointerDown["pointerdown\\nCreate Element"]\n' +
        '    pointerMove["pointermove\\nUpdate Points"]\n' +
        '    pointerUp["pointerup\\nFinalize / Multi-Point"]\n' +
        '    snapAngle["snapAngle()\\n15-degree Snap"]\n' +
        "  end\n" +
        "\n" +
        '  subgraph multipoint["Multi-Point Creation"]\n' +
        '    multiPointCreation["useMultiPointCreation()\\nClick-to-Place"]\n' +
        '    rubberBand["renderRubberBand()\\nDashed Preview"]\n' +
        '    computeDims["computeDimensionsFromPoints()\\nBounds Sync"]\n' +
        "  end\n" +
        "\n" +
        '  subgraph rendering["Rendering Pipeline"]\n' +
        '    renderElement["renderElement()\\nDispatch by Type"]\n' +
        '    shapeGen["generateShape()\\nRoughJS Cache"]\n' +
        '    roughPath["RoughJS linearPath()\\nHand-drawn Shaft"]\n' +
        '    renderArrowheads["renderArrowheads()\\nStart + End Tips"]\n' +
        '    drawArrowhead["drawArrowhead()\\nAngle Math"]\n' +
        "  end\n" +
        "\n" +
        '  subgraph interactive["Interactive Overlays"]\n' +
        '    renderInteractive["renderInteractiveScene()\\nSelection + Editor"]\n' +
        '    pointHandles["renderPointHandles()\\nVertex Circles"]\n' +
        '    midpointIndicator["renderMidpointIndicator()\\nSegment Midpoints"]\n' +
        '    hitTest["hitTestArrow()\\nSegment Distance"]\n' +
        '    arrowBounds["getElementBounds()\\nBounding Box"]\n' +
        "  end\n" +
        "\n" +
        '  subgraph orchestrator["Canvas Orchestration"]\n' +
        '    canvasContainer["CanvasContainer.vue\\nRoot Component"]\n' +
        '    sceneRenderer["useSceneRenderer()\\n3 Canvas Layers"]\n' +
        '    renderer["useRenderer()\\nRAF Dirty Flags"]\n' +
        "  end\n" +
        "\n" +
        '  toolbarButton -->|"clicks"| useTool\n' +
        '  toolbarButton -->|"displays"| toolIcon\n' +
        '  useTool -->|"sets activeTool"| pointerDown\n' +
        '  toolTypes -.->|"isLinearTool()"| pointerMove\n' +
        '  toolTypes -.->|"isDrawingTool()"| pointerDown\n' +
        '  pointerDown -->|"calls"| createElement\n' +
        '  createElement -->|"satisfies"| arrowType\n' +
        '  createElement -->|"uses"| pointType\n' +
        '  arrowType -->|"contains"| arrowheadType\n' +
        '  arrowType -->|"contains"| pointType\n' +
        '  pointerMove -->|"Shift held"| snapAngle\n' +
        '  pointerMove -->|"updates"| mutateElement\n' +
        '  pointerUp -->|"valid arrow"| multiPointCreation\n' +
        '  multiPointCreation -->|"Shift snap"| snapAngle\n' +
        '  multiPointCreation -->|"appends points"| mutateElement\n' +
        '  multiPointCreation -->|"recalculates"| computeDims\n' +
        '  multiPointCreation -->|"preview"| rubberBand\n' +
        '  mutateElement -->|"bumps version"| shapeGen\n' +
        '  renderElement -->|"generates"| shapeGen\n' +
        '  shapeGen -->|"arrow branch"| roughPath\n' +
        '  renderElement -->|"arrow type"| renderArrowheads\n' +
        '  renderArrowheads -->|"per endpoint"| drawArrowhead\n' +
        '  renderInteractive -->|"linear editor"| pointHandles\n' +
        '  renderInteractive -->|"hovered segment"| midpointIndicator\n' +
        '  renderInteractive -->|"multi-point"| rubberBand\n' +
        '  hitTest -.->|"selection"| arrowBounds\n' +
        '  canvasContainer -->|"wires"| useTool\n' +
        '  canvasContainer -->|"wires"| sceneRenderer\n' +
        '  sceneRenderer -->|"static layer"| renderElement\n' +
        '  sceneRenderer -->|"interactive layer"| renderInteractive\n' +
        '  sceneRenderer -->|"composes"| renderer\n' +
        "\n" +
        '  click toolbarButton nodeClickHandler "View details"\n' +
        '  click toolIcon nodeClickHandler "View details"\n' +
        '  click useTool nodeClickHandler "View details"\n' +
        '  click toolTypes nodeClickHandler "View details"\n' +
        '  click createElement nodeClickHandler "View details"\n' +
        '  click arrowType nodeClickHandler "View details"\n' +
        '  click arrowheadType nodeClickHandler "View details"\n' +
        '  click pointType nodeClickHandler "View details"\n' +
        '  click mutateElement nodeClickHandler "View details"\n' +
        '  click pointerDown nodeClickHandler "View details"\n' +
        '  click pointerMove nodeClickHandler "View details"\n' +
        '  click pointerUp nodeClickHandler "View details"\n' +
        '  click snapAngle nodeClickHandler "View details"\n' +
        '  click multiPointCreation nodeClickHandler "View details"\n' +
        '  click rubberBand nodeClickHandler "View details"\n' +
        '  click computeDims nodeClickHandler "View details"\n' +
        '  click renderElement nodeClickHandler "View details"\n' +
        '  click shapeGen nodeClickHandler "View details"\n' +
        '  click roughPath nodeClickHandler "View details"\n' +
        '  click renderArrowheads nodeClickHandler "View details"\n' +
        '  click drawArrowhead nodeClickHandler "View details"\n' +
        '  click renderInteractive nodeClickHandler "View details"\n' +
        '  click pointHandles nodeClickHandler "View details"\n' +
        '  click midpointIndicator nodeClickHandler "View details"\n' +
        '  click hitTest nodeClickHandler "View details"\n' +
        '  click arrowBounds nodeClickHandler "View details"\n' +
        '  click canvasContainer nodeClickHandler "View details"\n' +
        '  click sceneRenderer nodeClickHandler "View details"\n' +
        '  click renderer nodeClickHandler "View details"\n' +
        "\n" +
        "  classDef component fill:#a855f7,stroke:#c084fc,color:#fff\n" +
        "  classDef composable fill:#7c3aed,stroke:#a78bfa,color:#fff\n" +
        "  classDef utility fill:#6d28d9,stroke:#8b5cf6,color:#fff\n" +
        "  classDef external fill:#525252,stroke:#737373,color:#fff\n" +
        "  classDef event fill:#d8b4fe,stroke:#e9d5ff,color:#000\n" +
        "  classDef data fill:#9333ea,stroke:#a855f7,color:#fff\n" +
        "\n" +
        "  class toolbarButton component\n" +
        "  class toolIcon data\n" +
        "  class useTool composable\n" +
        "  class toolTypes data\n" +
        "  class createElement utility\n" +
        "  class arrowType data\n" +
        "  class arrowheadType data\n" +
        "  class pointType data\n" +
        "  class mutateElement utility\n" +
        "  class pointerDown event\n" +
        "  class pointerMove event\n" +
        "  class pointerUp event\n" +
        "  class snapAngle utility\n" +
        "  class multiPointCreation composable\n" +
        "  class rubberBand utility\n" +
        "  class computeDims utility\n" +
        "  class renderElement utility\n" +
        "  class shapeGen utility\n" +
        "  class roughPath external\n" +
        "  class renderArrowheads utility\n" +
        "  class drawArrowhead utility\n" +
        "  class renderInteractive utility\n" +
        "  class pointHandles utility\n" +
        "  class midpointIndicator utility\n" +
        "  class hitTest utility\n" +
        "  class arrowBounds utility\n" +
        "  class canvasContainer component\n" +
        "  class sceneRenderer composable\n" +
        "  class renderer composable\n";

      var NODES = {
        toolbarButton: {
          title: "DrawingToolbar Arrow Button",
          content:
            "<h3>Overview</h3><p>The arrow tool appears as button #5 in the DrawingToolbar, activated by clicking or pressing the <code>a</code> key (or numpad <code>5</code>). When active, the button highlights to show the arrow tool is selected.</p><h3>Key Code</h3><pre><code>const tools = [\n  { type: 'hand', label: 'Hand', shortcutNumber: null },\n  { type: 'selection', label: 'Selection', shortcutNumber: 1 },\n  { type: 'rectangle', label: 'Rectangle', shortcutNumber: 2 },\n  { type: 'diamond', label: 'Diamond', shortcutNumber: 3 },\n  { type: 'ellipse', label: 'Ellipse', shortcutNumber: 4 },\n  { type: 'arrow', label: 'Arrow', shortcutNumber: 5 },\n]</code></pre><h3>How It Connects</h3><ul><li>Calls <code>onSetTool('arrow')</code> prop from CanvasContainer</li><li>Renders the arrow SVG icon via <code>v-html</code></li></ul>",
          files: ["app/features/tools/components/DrawingToolbar.vue:12-18"],
        },
        toolIcon: {
          title: "Arrow Tool SVG Icon",
          content:
            '<h3>Overview</h3><p>SVG icon definition showing a diagonal line with an arrowhead polyline. Rendered at 24x24 viewBox inside the toolbar button.</p><h3>Key Code</h3><pre><code>arrow: {\n  viewBox: \'0 0 24 24\',\n  paths: \'&lt;g stroke="currentColor" stroke-width="1.5"\n    fill="none" stroke-linecap="round"\n    stroke-linejoin="round"&gt;\n    &lt;line x1="5" y1="19" x2="19" y2="5"/&gt;\n    &lt;polyline points="10,5 19,5 19,14"/&gt;\n  &lt;/g&gt;\',\n}</code></pre>',
          files: ["app/features/tools/components/toolIcons.ts:42-48"],
        },
        useTool: {
          title: "useTool() Composable",
          content:
            "<h3>Overview</h3><p>Global composable managing active tool state via <code>shallowRef&lt;ToolType&gt;</code>. Listens for keyboard shortcuts (<code>a</code> key maps to arrow) and exposes <code>activeTool</code> + <code>setTool()</code>. All drawing composables read from this reactive ref.</p><h3>Key Code</h3><pre><code>export function useTool(): UseToolReturn {\n  const activeTool = shallowRef&lt;ToolType&gt;('selection')\n\n  function setTool(tool: ToolType): void {\n    activeTool.value = tool\n  }\n\n  useEventListener(document, 'keydown', (e) =&gt; {\n    const tool = KEY_TO_TOOL[e.key]\n    if (!tool) return\n    setTool(tool)\n  })\n\n  return { activeTool, setTool }\n}</code></pre><h3>Activation Flow</h3><ul><li>Keyboard: <code>'a'</code> key or numpad <code>'5'</code> sets <code>activeTool = 'arrow'</code></li><li>Toolbar click: <code>setTool('arrow')</code> called by DrawingToolbar</li><li>All interaction composables watch <code>activeTool</code> reactively</li></ul>",
          files: ["app/features/tools/useTool.ts:25-50"],
        },
        toolTypes: {
          title: "Tool Type Guards",
          content:
            "<h3>Overview</h3><p>TypeScript type definitions and guard functions that distinguish arrow from shape tools. Arrow is the only <code>LinearToolType</code>, enabling special multi-point handling in drawing interaction.</p><h3>Key Code</h3><pre><code>export type LinearToolType = 'arrow'\n\nexport function isDrawingTool(tool: ToolType): tool is DrawingToolType {\n  return tool === 'rectangle' || tool === 'ellipse'\n    || tool === 'diamond' || tool === 'arrow'\n}\n\nexport function isLinearTool(tool: ToolType): tool is LinearToolType {\n  return tool === 'arrow'\n}</code></pre><h3>Why It Matters</h3><ul><li><code>isDrawingTool()</code> gates entry to pointerdown handler</li><li><code>isLinearTool()</code> triggers the points-based geometry path (vs width/height for shapes)</li></ul>",
          files: ["app/features/tools/types.ts:1-17"],
        },
        createElement: {
          title: "createElement() Arrow Factory",
          content:
            "<h3>Overview</h3><p>Polymorphic factory that creates any element type. For arrows, initializes with a single point at <code>[0,0]</code>, default arrowheads (<code>startArrowhead: null</code>, <code>endArrowhead: 'arrow'</code>), and shared styling defaults.</p><h3>Key Code</h3><pre><code>if (type === 'arrow') {\n  return {\n    ...base,\n    type: 'arrow',\n    points: [createPoint(0, 0)],\n    startArrowhead: null,\n    endArrowhead: 'arrow',\n  } satisfies ExcalidrawArrowElement\n}</code></pre><h3>Details</h3><ul><li><code>base</code> includes: id (nanoid), x, y, width=0, height=0, strokeColor, roughness, seed, etc.</li><li>The <code>satisfies</code> keyword ensures type safety without casting</li><li>A second point is added during the first pointermove</li></ul>",
          files: ["app/features/elements/createElement.ts:13-51"],
        },
        arrowType: {
          title: "ExcalidrawArrowElement Interface",
          content:
            "<h3>Overview</h3><p>The TypeScript interface that defines arrow elements. Extends <code>ExcalidrawElementBase</code> with arrow-specific properties: a <code>points</code> array for multi-segment geometry and arrowhead style properties.</p><h3>Key Code</h3><pre><code>export interface ExcalidrawArrowElement\n  extends ExcalidrawElementBase {\n  readonly type: 'arrow'\n  /** Relative points \u2014 first is always [0,0],\n   *  rest are offsets from element.x/y */\n  points: readonly Point[]\n  startArrowhead: ArrowheadType | null\n  endArrowhead: ArrowheadType\n}</code></pre><h3>Key Invariants</h3><ul><li><code>points[0]</code> is always <code>{ x: 0, y: 0 }</code> (enforced by normalizePoints)</li><li>All other points are relative offsets from <code>element.x</code> / <code>element.y</code></li><li><code>readonly type: 'arrow'</code> enables discriminated union narrowing</li></ul>",
          files: ["app/features/elements/types.ts:38-44"],
        },
        arrowheadType: {
          title: "ArrowheadType Union",
          content:
            "<h3>Overview</h3><p>Literal union defining three arrowhead rendering styles. Determines how endpoints are visually drawn by <code>drawArrowhead()</code>.</p><h3>Key Code</h3><pre><code>export type ArrowheadType = 'arrow' | 'triangle' | 'none'</code></pre><h3>Rendering Behavior</h3><ul><li><code>'arrow'</code> \u2014 Two open lines forming a V-shape at the tip</li><li><code>'triangle'</code> \u2014 Filled triangle polygon at the tip</li><li><code>'none'</code> \u2014 No arrowhead rendered</li><li>Default: <code>startArrowhead = null</code> (no start head), <code>endArrowhead = 'arrow'</code></li></ul>",
          files: ["app/features/elements/types.ts:3"],
        },
        pointType: {
          title: "Point Interface & createPoint()",
          content:
            "<h3>Overview</h3><p>Minimal 2D coordinate structure used throughout for positions, deltas, and arrow vertices. <code>createPoint()</code> is a simple factory for consistent object creation.</p><h3>Key Code</h3><pre><code>export interface Point {\n  x: number\n  y: number\n}\n\nexport function createPoint(x: number, y: number): Point {\n  return { x, y }\n}</code></pre><h3>Usage in Arrows</h3><ul><li>Arrow <code>points</code> array stores Point objects as relative offsets</li><li>First point always at <code>createPoint(0, 0)</code></li><li>Subsequent points at <code>createPoint(dx, dy)</code> from origin</li></ul>",
          files: ["app/shared/math.ts:1-17"],
        },
        mutateElement: {
          title: "mutateElement() with Version Bump",
          content:
            "<h3>Overview</h3><p>In-place mutation utility for any element. Accepts partial updates including arrow-specific fields (points, arrowheads). Always bumps <code>versionNonce</code> to invalidate the RoughJS shape cache.</p><h3>Key Code</h3><pre><code>type MutableFields =\n  Partial&lt;Omit&lt;ExcalidrawElementBase, 'id' | 'type'&gt;&gt;\n  &amp; Partial&lt;Pick&lt;ExcalidrawArrowElement,\n    'points' | 'startArrowhead' | 'endArrowhead'&gt;&gt;\n\nexport function mutateElement&lt;T extends ExcalidrawElement&gt;(\n  element: T,\n  updates: MutableFields,\n): T {\n  Object.assign(element, updates,\n    { versionNonce: randomVersionNonce() })\n  return element\n}</code></pre><h3>Cache Invalidation</h3><ul><li>Every mutation bumps <code>versionNonce</code></li><li><code>generateShape()</code> compares nonce \u2014 cache miss triggers RoughJS regeneration</li></ul>",
          files: ["app/features/elements/mutateElement.ts:1-13"],
        },
        pointerDown: {
          title: "Pointer Down \u2014 Create Arrow Element",
          content:
            "<h3>Overview</h3><p>When user clicks canvas with arrow tool active, creates a new arrow element at the click position. Guards against panning, space-held, multi-point mode, and non-left clicks.</p><h3>Key Code</h3><pre><code>useEventListener(canvasRef, 'pointerdown', (e) =&gt; {\n  if (spaceHeld.value || isPanning.value) return\n  if (multiElement?.value) return\n  const tool = activeTool.value\n  if (!isDrawingTool(tool)) return\n  if (e.button !== 0) return\n\n  const scene = toScene(e.offsetX, e.offsetY)\n  originX = scene.x\n  originY = scene.y\n  newElement.value = createElement(tool, originX, originY)\n  canvasRef.value?.setPointerCapture(e.pointerId)\n})</code></pre><h3>Flow</h3><ul><li>Converts screen coords to scene coords via <code>toScene()</code></li><li>Stores origin for delta calculation in pointermove</li><li>Captures pointer for reliable drag tracking</li></ul>",
          files: ["app/features/tools/useDrawingInteraction.ts:49-63"],
        },
        pointerMove: {
          title: "Pointer Move \u2014 Update Arrow Points",
          content:
            "<h3>Overview</h3><p>During drag, calculates dx/dy from origin to cursor. For linear tools (arrows), builds a two-point array and optionally snaps angle to 15\u00b0 increments when Shift is held. Updates element via <code>mutateElement()</code>.</p><h3>Key Code</h3><pre><code>if (isLinearTool(activeTool.value)) {\n  let dx = scene.x - originX\n  let dy = scene.y - originY\n\n  if (e.shiftKey) {\n    const snapped = snapAngle(dx, dy)\n    dx = snapped.x\n    dy = snapped.y\n  }\n\n  const points = [\n    createPoint(0, 0),\n    createPoint(dx, dy)\n  ]\n\n  mutateElement(newElement.value, {\n    points,\n    x: originX, y: originY,\n    width: Math.abs(dx),\n    height: Math.abs(dy),\n  })\n  markNewElementDirty()\n}</code></pre><h3>Angle Snapping</h3><ul><li>Hold <code>Shift</code> to snap to 0\u00b0, 15\u00b0, 30\u00b0, 45\u00b0, 60\u00b0, 75\u00b0, 90\u00b0 etc.</li><li>Preserves line length while quantizing direction</li></ul>",
          files: ["app/features/tools/useDrawingInteraction.ts:65-91"],
        },
        pointerUp: {
          title: "Pointer Up \u2014 Finalize or Enter Multi-Point",
          content:
            "<h3>Overview</h3><p>On mouse release, validates the arrow (width &gt; 1 or height &gt; 1). If valid and it's a linear tool, enters multi-point mode for adding more vertices. Otherwise reverts to selection tool.</p><h3>Key Code</h3><pre><code>const isValid = el.width &gt; 1 || el.height &gt; 1\n\nif (isValid) {\n  onElementCreated(el)\n}\n\n// Enter multi-point mode for arrows\nif (isLinearTool(activeTool.value)\n    &amp;&amp; isValid\n    &amp;&amp; onMultiPointStart\n    &amp;&amp; el.type === 'arrow') {\n  newElement.value = null\n  markNewElementDirty()\n  markStaticDirty()\n  onMultiPointStart(el)\n  return\n}\n\nactiveTool.value = 'selection'\nnewElement.value = null</code></pre><h3>Key Decision</h3><ul><li>Arrows get special treatment: they enter multi-point mode instead of reverting to selection</li><li>This allows users to keep clicking to add more points after the initial drag</li></ul>",
          files: ["app/features/tools/useDrawingInteraction.ts:112-137"],
        },
        snapAngle: {
          title: "snapAngle() \u2014 15\u00b0 Angle Quantization",
          content:
            "<h3>Overview</h3><p>Snaps a direction vector (dx, dy) to the nearest 15\u00b0 increment. Uses <code>atan2</code> to get angle, rounds to \u03c0/12 radians, preserves original length via <code>Math.hypot</code>. Called whenever Shift is held during drawing or multi-point placement.</p><h3>Key Code</h3><pre><code>export function snapAngle(\n  dx: number,\n  dy: number,\n): Point {\n  const angle = Math.atan2(dy, dx)\n  const snapped = Math.round(\n    angle / (Math.PI / 12)\n  ) * (Math.PI / 12)\n  const length = Math.hypot(dx, dy)\n  return {\n    x: Math.cos(snapped) * length,\n    y: Math.sin(snapped) * length,\n  }\n}</code></pre><h3>Snap Angles</h3><ul><li>0\u00b0, 15\u00b0, 30\u00b0, 45\u00b0, 60\u00b0, 75\u00b0, 90\u00b0, and their reflections</li><li>24 possible directions total (360\u00b0 / 15\u00b0)</li><li>Length is preserved \u2014 only direction changes</li></ul>",
          files: ["app/shared/math.ts:62-67"],
        },
        multiPointCreation: {
          title: "useMultiPointCreation() Composable",
          content:
            "<h3>Overview</h3><p>Activates after the initial arrow drag. Each click adds a new point to the arrow. Supports Shift+click for angle snapping, double-click or Escape/Enter to finalize. Tracks cursor position for rubber-band preview.</p><h3>Key Code</h3><pre><code>useEventListener(canvasRef, 'pointerdown', (e) =&gt; {\n  const el = multiElement.value\n  if (!el) return\n\n  const scene = toScene(e.offsetX, e.offsetY)\n  const lastPt = el.points.at(-1)!\n  let dx = scene.x - (lastPt.x + el.x)\n  let dy = scene.y - (lastPt.y + el.y)\n\n  if (e.shiftKey) {\n    const snapped = snapAngle(dx, dy)\n    dx = snapped.x\n    dy = snapped.y\n  }\n\n  const newPt = createPoint(\n    lastPt.x + dx, lastPt.y + dy\n  )\n  const newPoints = [...el.points, newPt]\n  const dims = computeDimensionsFromPoints(\n    newPoints\n  )\n  mutateElement(el, {\n    points: newPoints,\n    width: dims.width,\n    height: dims.height,\n  })\n})</code></pre><h3>Finalization</h3><ul><li>Double-click: finalizes the arrow</li><li>Escape/Enter: finalizes and returns to selection tool</li></ul>",
          files: ["app/features/linear-editor/useMultiPointCreation.ts:25-119"],
        },
        rubberBand: {
          title: "renderRubberBand() Preview Line",
          content:
            "<h3>Overview</h3><p>Draws a dashed line from the last arrow point to the current cursor position during multi-point creation. Gives visual feedback of where the next segment will go.</p><h3>Key Code</h3><pre><code>export function renderRubberBand(\n  ctx: CanvasRenderingContext2D,\n  element: ExcalidrawArrowElement,\n  cursorPoint: Point,\n  zoom: number,\n): void {\n  const lastPt = element.points.at(-1)\n  if (!lastPt) return\n\n  const sceneX = lastPt.x + element.x\n  const sceneY = lastPt.y + element.y\n\n  ctx.strokeStyle = RUBBER_BAND_COLOR\n  ctx.lineWidth = RUBBER_BAND_WIDTH / zoom\n  ctx.setLineDash(\n    RUBBER_BAND_DASH.map(d =&gt; d / zoom)\n  )\n  ctx.beginPath()\n  ctx.moveTo(sceneX, sceneY)\n  ctx.lineTo(cursorPoint.x, cursorPoint.y)\n  ctx.stroke()\n}</code></pre>",
          files: ["app/features/linear-editor/renderLinearEditor.ts:21-44"],
        },
        computeDims: {
          title: "computeDimensionsFromPoints()",
          content:
            "<h3>Overview</h3><p>Calculates the bounding width/height from all relative points. Called after every point mutation to keep <code>element.width</code> and <code>element.height</code> in sync for selection bounds and rendering.</p><h3>Key Code</h3><pre><code>export function computeDimensionsFromPoints(\n  points: readonly Point[],\n): { width: number; height: number } {\n  let minX = Infinity, minY = Infinity\n  let maxX = -Infinity, maxY = -Infinity\n\n  for (const p of points) {\n    if (p.x &lt; minX) minX = p.x\n    if (p.y &lt; minY) minY = p.y\n    if (p.x &gt; maxX) maxX = p.x\n    if (p.y &gt; maxY) maxY = p.y\n  }\n\n  return {\n    width: maxX - minX,\n    height: maxY - minY,\n  }\n}</code></pre>",
          files: ["app/features/linear-editor/pointHandles.ts:170-189"],
        },
        renderElement: {
          title: "renderElement() Dispatch",
          content:
            "<h3>Overview</h3><p>Entry point for rendering any element on the static canvas. For arrows: generates the RoughJS hand-drawn shaft, then overlays arrowheads. Early-exits if arrow has fewer than 2 points.</p><h3>Key Code</h3><pre><code>export function renderElement(\n  ctx: CanvasRenderingContext2D,\n  rc: RoughCanvas,\n  element: ExcalidrawElement,\n): void {\n  if (element.isDeleted) return\n  if (element.type === 'arrow'\n    &amp;&amp; element.points.length &lt; 2) return\n\n  ctx.save()\n  ctx.translate(element.x, element.y)\n  ctx.globalAlpha = element.opacity / 100\n\n  const drawable = generateShape(element)\n  rc.draw(drawable)\n\n  if (element.type === 'arrow') {\n    renderArrowheads(ctx, element)\n  }\n\n  ctx.restore()\n}</code></pre><h3>Render Order</h3><ul><li>1. Translate canvas to element position</li><li>2. Draw RoughJS shaft (hand-drawn line)</li><li>3. Draw arrowheads on top of shaft</li></ul>",
          files: ["app/features/rendering/renderElement.ts:6-30"],
        },
        shapeGen: {
          title: "generateShape() \u2014 RoughJS Cache",
          content:
            "<h3>Overview</h3><p>Generates and caches RoughJS <code>Drawable</code> objects by element ID and versionNonce. When a mutation bumps the nonce, the cache misses and a new drawable is generated. This avoids expensive RoughJS recalculation every frame.</p><h3>Key Code</h3><pre><code>export function generateShape(\n  element: ExcalidrawElement,\n): Drawable {\n  const cached = shapeCache.get(element.id)\n  if (cached\n    &amp;&amp; cached.nonce === element.versionNonce) {\n    return cached.drawable\n  }\n\n  const drawable = generateDrawable(element)\n  shapeCache.set(element.id, {\n    nonce: element.versionNonce,\n    drawable,\n  })\n  return drawable\n}</code></pre><h3>Cache Strategy</h3><ul><li>Key: <code>element.id</code></li><li>Validity: <code>versionNonce</code> must match</li><li>Every <code>mutateElement()</code> call bumps nonce \u2192 cache miss \u2192 regenerate</li></ul>",
          files: ["app/features/rendering/shapeGenerator.ts:64-73"],
        },
        roughPath: {
          title: "RoughJS linearPath()",
          content:
            "<h3>Overview</h3><p>Uses RoughJS <code>generator.linearPath()</code> to create the hand-drawn arrow shaft. Converts the Point array to <code>[x, y]</code> tuple format and passes element styling options (color, stroke width, roughness, seed).</p><h3>Key Code</h3><pre><code>if (element.type === 'arrow') {\n  const { points } = element\n  const pts = points.map(\n    p =&gt; [p.x, p.y] satisfies [number, number]\n  )\n  return generator.linearPath(pts, options)\n}</code></pre><h3>RoughJS Options</h3><pre><code>function elementToRoughOptions(element) {\n  return {\n    seed: element.seed,\n    roughness: element.roughness,\n    stroke: element.strokeColor,\n    strokeWidth: element.strokeWidth,\n    fillStyle: element.fillStyle,\n  }\n}</code></pre>",
          files: ["app/features/rendering/shapeGenerator.ts:34-42"],
        },
        renderArrowheads: {
          title: "renderArrowheads() Entry Point",
          content:
            "<h3>Overview</h3><p>Orchestrates arrowhead rendering at both endpoints. Checks each arrowhead property and delegates to <code>drawArrowhead()</code> with the correct direction (tip + adjacent point for angle calculation).</p><h3>Key Code</h3><pre><code>export function renderArrowheads(\n  ctx: CanvasRenderingContext2D,\n  element: ExcalidrawArrowElement,\n): void {\n  const { points, endArrowhead,\n    startArrowhead, strokeWidth,\n    strokeColor } = element\n  if (points.length &lt; 2) return\n\n  if (endArrowhead\n    &amp;&amp; endArrowhead !== 'none') {\n    const tip = points.at(-1)!\n    const prev = points.at(-2)!\n    drawArrowhead(ctx, prev, tip,\n      endArrowhead, strokeWidth, strokeColor)\n  }\n\n  if (startArrowhead\n    &amp;&amp; startArrowhead !== 'none') {\n    const tip = points[0]!\n    const next = points[1]!\n    drawArrowhead(ctx, next, tip,\n      startArrowhead, strokeWidth, strokeColor)\n  }\n}</code></pre>",
          files: ["app/features/rendering/arrowhead.ts:4-22"],
        },
        drawArrowhead: {
          title: "drawArrowhead() \u2014 Angle Math",
          content:
            "<h3>Overview</h3><p>The core arrowhead geometry function. Calculates the arrow direction angle via <code>atan2</code>, then computes two \"wing\" points at \u00b130\u00b0 (\u03c0/6 radians) from the direction. Head length scales with stroke width: <code>max(10, strokeWidth * 4)</code>.</p><h3>Key Code</h3><pre><code>function drawArrowhead(\n  ctx, from, tip, style,\n  strokeWidth, color,\n) {\n  const angle = Math.atan2(\n    tip.y - from.y, tip.x - from.x\n  )\n  const headLength = Math.max(\n    10, strokeWidth * 4\n  )\n  const headAngle = Math.PI / 6  // 30\u00b0\n\n  const wingLX = tip.x\n    - headLength * Math.cos(angle - headAngle)\n  const wingLY = tip.y\n    - headLength * Math.sin(angle - headAngle)\n  const wingRX = tip.x\n    - headLength * Math.cos(angle + headAngle)\n  const wingRY = tip.y\n    - headLength * Math.sin(angle + headAngle)\n\n  // 'arrow': two lines from tip\n  // 'triangle': filled polygon\n}</code></pre><h3>Geometry</h3><ul><li><code>angle</code>: direction from previous point to tip (atan2)</li><li><code>headAngle</code>: \u00b130\u00b0 spread for the V-shape</li><li><code>headLength</code>: how far back the wings extend</li><li>Two rendering modes: open lines ('arrow') or filled triangle ('triangle')</li></ul>",
          files: ["app/features/rendering/arrowhead.ts:24-67"],
        },
        renderInteractive: {
          title: "renderInteractiveScene()",
          content:
            "<h3>Overview</h3><p>Renders all interactive overlays on the top canvas layer: selection borders, point handles for linear editing, midpoint indicators, and rubber-band preview during multi-point creation.</p><h3>Key Code</h3><pre><code>export function renderInteractiveScene(\n  ctx, selectedElements, zoom,\n  selectionBox, linearEditorState,\n  multiPointState,\n) {\n  // ... selection borders for shapes\n\n  if (linearEditorState) {\n    renderSelectionBorder(\n      ctx, linearEditorState.element, zoom)\n    renderPointHandles(\n      ctx, linearEditorState.element,\n      linearEditorState.selectedPointIndices,\n      zoom)\n    if (linearEditorState.hoveredMidpointIndex\n        !== null) {\n      renderMidpointIndicator(\n        ctx, linearEditorState.element,\n        linearEditorState.hoveredMidpointIndex,\n        zoom)\n    }\n  }\n\n  if (multiPointState) {\n    renderRubberBand(\n      ctx, multiPointState.element,\n      multiPointState.cursorPoint, zoom)\n  }\n}</code></pre>",
          files: ["app/features/rendering/renderInteractive.ts:143-176"],
        },
        pointHandles: {
          title: "renderPointHandles() \u2014 Vertex Circles",
          content:
            "<h3>Overview</h3><p>Renders filled circles at each arrow vertex in scene coordinates. Selected points are filled blue; unselected are white with blue stroke. Handle radius scales with zoom (5px at zoom=1).</p><h3>Key Code</h3><pre><code>export function renderPointHandles(\n  ctx, element, selectedIndices, zoom,\n) {\n  const positions = getPointPositions(element)\n  const radius = POINT_HANDLE_RADIUS / zoom\n\n  for (let i = 0; i &lt; positions.length; i++) {\n    const pos = positions[i]!\n    const isSelected = selectedIndices.has(i)\n\n    ctx.beginPath()\n    ctx.arc(\n      pos.x, pos.y, radius, 0, Math.PI * 2)\n    ctx.fillStyle = isSelected\n      ? POINT_HANDLE_SELECTED_FILL\n      : POINT_HANDLE_FILL\n    ctx.strokeStyle = POINT_HANDLE_STROKE\n    ctx.fill()\n    ctx.stroke()\n  }\n}</code></pre><h3>Visual Constants</h3><ul><li>Radius: 5px (scales with zoom)</li><li>Selected: <code>#4a90d9</code> filled blue</li><li>Unselected: white fill, <code>#4a90d9</code> stroke</li></ul>",
          files: ["app/features/linear-editor/renderLinearEditor.ts:50-76"],
        },
        midpointIndicator: {
          title: "renderMidpointIndicator()",
          content:
            "<h3>Overview</h3><p>Renders a small circle at the midpoint between two consecutive arrow points when the user hovers over that segment. Clicking the midpoint inserts a new point, splitting the segment.</p><h3>Key Code</h3><pre><code>export function renderMidpointIndicator(\n  ctx, element, hoveredSegmentIndex, zoom,\n) {\n  const midpoints = getMidpointPositions(element)\n  const midpoint = midpoints[hoveredSegmentIndex]\n  if (!midpoint) return\n\n  const radius = MIDPOINT_HANDLE_RADIUS / zoom\n\n  ctx.beginPath()\n  ctx.arc(\n    midpoint.x, midpoint.y,\n    radius, 0, Math.PI * 2\n  )\n  ctx.fillStyle = MIDPOINT_HANDLE_FILL\n  ctx.strokeStyle = MIDPOINT_HANDLE_STROKE\n  ctx.fill()\n  ctx.stroke()\n}</code></pre><h3>Details</h3><ul><li>Radius: 3px (smaller than point handles)</li><li>Only visible on hover, not permanently shown</li><li>Uses <code>getMidpointPositions()</code> which calculates midpoint of each segment</li></ul>",
          files: ["app/features/linear-editor/renderLinearEditor.ts:82-106"],
        },
        hitTest: {
          title: "hitTestArrow() \u2014 Segment Distance",
          content:
            "<h3>Overview</h3><p>Specialized hit testing for arrow elements. Converts all relative points to scene coordinates, then checks distance from test point to each line segment. Uses parametric projection (clamped 0\u20131) for closest-point calculation.</p><h3>Key Code</h3><pre><code>function hitTestArrow(\n  point: Point,\n  el: ExcalidrawArrowElement,\n  threshold: number,\n): boolean {\n  const pts = el.points.map(\n    p =&gt; ({ x: p.x + el.x, y: p.y + el.y })\n  )\n  for (let i = 0; i &lt; pts.length - 1; i++) {\n    if (distanceToSegment(\n      point, pts[i]!, pts[i + 1]!\n    ) &lt;= threshold) return true\n  }\n  return false\n}\n\n// Parametric closest point on segment\nexport function distanceToSegment(\n  point, a, b,\n) {\n  const t = clamp(\n    dot / lengthSq, 0, 1\n  )\n  // ... project and measure distance\n}</code></pre>",
          files: ["app/features/selection/hitTest.ts:123-144"],
        },
        arrowBounds: {
          title: "getElementBounds() for Arrows",
          content:
            "<h3>Overview</h3><p>Computes min/max bounding box from all arrow points in scene space. Used for fast-reject in hit testing and selection box culling.</p><h3>Key Code</h3><pre><code>export function getElementBounds(\n  element: ExcalidrawElement,\n): Bounds {\n  if (element.type === 'arrow') {\n    const xs = element.points.map(\n      p =&gt; p.x + element.x\n    )\n    const ys = element.points.map(\n      p =&gt; p.y + element.y\n    )\n    return [\n      Math.min(...xs),\n      Math.min(...ys),\n      Math.max(...xs),\n      Math.max(...ys),\n    ]\n  }\n  // ... other shapes use x/y/width/height\n}</code></pre><h3>Why Different from Shapes</h3><ul><li>Shapes use simple <code>x, y, width, height</code> box</li><li>Arrows must iterate all points since they can zigzag in any direction</li></ul>",
          files: ["app/features/selection/bounds.ts:7-42"],
        },
        canvasContainer: {
          title: "CanvasContainer.vue \u2014 Root Component",
          content:
            "<h3>Overview</h3><p>The root drawing canvas component that wires together all arrow-related systems: tool state, drawing interaction, multi-point creation, scene rendering, and linear editor state.</p><h3>Key Code</h3><pre><code>const { activeTool, setTool } = useTool()\nconst newElement = shallowRef(null)\n\nconst editingLinearElement =\n  shallowRef(null)\nconst editingPointIndices =\n  shallowRef(new Set())\nconst editingHoveredMidpoint =\n  shallowRef(null)\n\nuseDrawingInteraction({\n  canvasRef: interactiveCanvasRef,\n  activeTool,\n  toScene, newElement,\n  onElementCreated(el) {\n    addElement(el)\n    select(el.id)\n    markInteractiveDirty()\n  },\n})\n\nuseSceneRenderer({\n  editingLinearElement,\n  editingPointIndices,\n  editingHoveredMidpoint,\n  multiElement, lastCursorPoint,\n})</code></pre><h3>Integration</h3><ul><li>Creates all ShallowRef state for linear editor</li><li>Passes to both drawing interaction and scene renderer</li><li>Mounts <code>DrawingToolbar</code> with tool props</li></ul>",
          files: ["app/features/canvas/components/CanvasContainer.vue:30-87"],
        },
        sceneRenderer: {
          title: "useSceneRenderer() \u2014 3 Canvas Layers",
          content:
            "<h3>Overview</h3><p>Composes the rendering pipeline with three distinct canvas layers: static (all committed elements), new-element (draft arrow during drawing), and interactive (selection + editor overlays). Assembles linear editor render state from Vue refs.</p><h3>Key Code</h3><pre><code>onRenderStatic(ctx) {\n  renderGrid(ctx, scrollX, scrollY, zoom,\n    width, height)\n  renderScene(ctx, rc, elements,\n    scrollX, scrollY, zoom)\n},\nonRenderNewElement(ctx) {\n  const el = newElement.value\n  if (!el || !rc) return\n  ctx.scale(zoom, zoom)\n  ctx.translate(scrollX, scrollY)\n  renderElement(ctx, rc, el)\n},\nonRenderInteractive(ctx) {\n  let linearEditorState = null\n  if (editingLinearElement?.value) {\n    linearEditorState = {\n      element: editingLinearElement.value,\n      selectedPointIndices:\n        editingPointIndices?.value,\n      hoveredMidpointIndex:\n        editingHoveredMidpoint?.value,\n    }\n  }\n  renderInteractiveScene(\n    ctx, selectedElements, zoom,\n    selectionBox, linearEditorState,\n    multiPointState)\n}</code></pre><h3>Layer Purpose</h3><ul><li><strong>Static</strong>: Grid + all committed elements (arrows, shapes)</li><li><strong>New element</strong>: Draft arrow being drawn right now</li><li><strong>Interactive</strong>: Selection borders, point handles, rubber band</li></ul>",
          files: ["app/features/canvas/composables/useSceneRenderer.ts:53-122"],
        },
        renderer: {
          title: "useRenderer() \u2014 RAF Dirty Flags",
          content:
            "<h3>Overview</h3><p>The core rendering loop using <code>useRafFn()</code> (requestAnimationFrame). Tracks three dirty flags \u2014 only redraws layers that have been marked dirty. This avoids full redraws every frame during idle.</p><h3>Key Code</h3><pre><code>useRafFn(() =&gt; {\n  const w = width.value\n  const h = height.value\n  if (w === 0 || h === 0) return\n\n  renderDirtyCanvas(\n    staticDirty, staticLayer,\n    dpr, w, h, '#ffffff',\n    onRenderStatic)\n  renderDirtyCanvas(\n    newElementDirty, newElementLayer,\n    dpr, w, h, undefined,\n    onRenderNewElement)\n  renderDirtyCanvas(\n    interactiveDirty, interactiveLayer,\n    dpr, w, h, undefined,\n    onRenderInteractive)\n})</code></pre><h3>Dirty Flag Flow</h3><ul><li><code>markNewElementDirty()</code> \u2014 called during arrow pointermove</li><li><code>markStaticDirty()</code> \u2014 called when element is committed</li><li><code>markInteractiveDirty()</code> \u2014 called on selection/editor changes</li><li>Only the flagged layer re-renders \u2192 smooth 60fps</li></ul>",
          files: ["app/features/canvas/composables/useRenderer.ts:32-97"],
        },
      };

      var LEGEND = [
        { label: "Component", color: "bg-node-component" },
        { label: "Composable", color: "bg-node-composable" },
        { label: "Utility", color: "bg-node-utility" },
        { label: "External", color: "bg-node-external" },
        { label: "Event", color: "bg-node-event" },
        { label: "Data", color: "bg-node-data" },
      ];

      function usePanZoom() {
        var viewportRef = useRef(null);
        var canvasRef = useRef(null);
        var zoomDisplayRef = useRef(null);
        var st = useRef({ zoom: 1, panX: 0, panY: 0 });
        var drag = useRef({ on: false, lx: 0, ly: 0 });

        var apply = useCallback(function () {
          var s = st.current;
          if (canvasRef.current)
            canvasRef.current.style.transform =
              "translate(" + s.panX + "px," + s.panY + "px) scale(" + s.zoom + ")";
          if (zoomDisplayRef.current)
            zoomDisplayRef.current.textContent = Math.round(s.zoom * 100) + "%";
        }, []);

        var fitToScreen = useCallback(
          function () {
            var svg = canvasRef.current?.querySelector("svg");
            var vp = viewportRef.current;
            if (!svg || !vp) return;
            var s = st.current;
            var vw = vp.clientWidth,
              vh = vp.clientHeight;
            var sw = svg.getBoundingClientRect().width / s.zoom;
            var sh = svg.getBoundingClientRect().height / s.zoom;
            var fit = Math.max(0.15, Math.min(2, Math.min((vw - 80) / sw, (vh - 80) / sh)));
            s.zoom = fit;
            s.panX = (vw - sw * fit) / 2;
            s.panY = (vh - sh * fit) / 2;
            apply();
          },
          [apply],
        );

        useEffect(
          function () {
            var vp = viewportRef.current;
            if (!vp) return;

            var onWheel = function (e) {
              e.preventDefault();
              var r = vp.getBoundingClientRect();
              var mx = e.clientX - r.left,
                my = e.clientY - r.top;
              var s = st.current;
              var f = e.deltaY < 0 ? 1.12 : 1 / 1.12;
              var nz = Math.min(4, Math.max(0.15, s.zoom * f));
              var sc = nz / s.zoom;
              s.panX = mx - sc * (mx - s.panX);
              s.panY = my - sc * (my - s.panY);
              s.zoom = nz;
              apply();
            };

            var onDown = function (e) {
              if (e.target.closest(".node")) return;
              drag.current = { on: true, lx: e.clientX, ly: e.clientY };
              vp.setPointerCapture(e.pointerId);
            };
            var onMove = function (e) {
              var d = drag.current;
              if (!d.on) return;
              st.current.panX += e.clientX - d.lx;
              st.current.panY += e.clientY - d.ly;
              d.lx = e.clientX;
              d.ly = e.clientY;
              apply();
            };
            var onUp = function () {
              drag.current.on = false;
            };

            vp.addEventListener("wheel", onWheel, { passive: false });
            vp.addEventListener("pointerdown", onDown);
            vp.addEventListener("pointermove", onMove);
            vp.addEventListener("pointerup", onUp);
            vp.addEventListener("pointercancel", onUp);
            window.addEventListener("resize", fitToScreen);

            return function () {
              vp.removeEventListener("wheel", onWheel);
              vp.removeEventListener("pointerdown", onDown);
              vp.removeEventListener("pointermove", onMove);
              vp.removeEventListener("pointerup", onUp);
              vp.removeEventListener("pointercancel", onUp);
              window.removeEventListener("resize", fitToScreen);
            };
          },
          [apply, fitToScreen],
        );

        var zoomIn = useCallback(
          function () {
            st.current.zoom = Math.min(4, st.current.zoom * 1.25);
            apply();
          },
          [apply],
        );
        var zoomOut = useCallback(
          function () {
            st.current.zoom = Math.max(0.15, st.current.zoom / 1.25);
            apply();
          },
          [apply],
        );

        return {
          viewportRef: viewportRef,
          canvasRef: canvasRef,
          zoomDisplayRef: zoomDisplayRef,
          zoomIn: zoomIn,
          zoomOut: zoomOut,
          fitToScreen: fitToScreen,
        };
      }

      function MermaidDiagram(props) {
        var ref = useRef(null);

        useEffect(
          function () {
            window.nodeClickHandler = props.onNodeClick;
            mermaid.initialize({
              startOnLoad: false,
              theme: "dark",
              themeVariables: {
                primaryColor: "#0a0a0a",
                primaryTextColor: "#ffffff",
                primaryBorderColor: "#2a2a2a",
                lineColor: "#a0a0a0",
                secondaryColor: "#000000",
                tertiaryColor: "#000000",
                background: "#000000",
                mainBkg: "#0a0a0a",
                nodeBorder: "#2a2a2a",
                clusterBkg: "rgba(10,10,10,0.8)",
                clusterBorder: "#7c3aed",
                titleColor: "#ffffff",
                edgeLabelBackground: "transparent",
              },
              flowchart: { useMaxWidth: false, htmlLabels: true, curve: "basis" },
              securityLevel: "loose",
            });
            mermaid.render("walkthrough-diagram", DIAGRAM).then(function (result) {
              if (ref.current) {
                ref.current.innerHTML = result.svg;
                if (result.bindFunctions) result.bindFunctions(ref.current);
              }
            });
            return function () {
              delete window.nodeClickHandler;
            };
          },
          [props.onNodeClick],
        );

        return React.createElement("div", { ref: ref, className: "mermaid-wrap" });
      }

      function DetailPanel(props) {
        useEffect(
          function () {
            var onKey = function (e) {
              if (e.key === "Escape") props.onClose();
            };
            document.addEventListener("keydown", onKey);
            return function () {
              document.removeEventListener("keydown", onKey);
            };
          },
          [props.onClose],
        );

        return React.createElement(
          "div",
          {
            className:
              "fixed top-4 right-4 bottom-4 w-[420px] z-30 bg-wt-surface border border-wt-border rounded-xl shadow-2xl flex flex-col overflow-hidden",
          },
          React.createElement("button", {
            onClick: props.onClose,
            className:
              "absolute top-3 right-3 z-10 w-7 h-7 rounded-md border border-wt-border bg-wt-raised text-wt-muted flex items-center justify-center text-lg hover:bg-wt-red hover:border-wt-red hover:text-white transition-colors",
            dangerouslySetInnerHTML: { __html: "&times;" },
          }),
          React.createElement(
            "div",
            { className: "flex-1 overflow-y-auto p-5" },
            React.createElement(
              "h2",
              { className: "text-lg font-bold text-wt-fg mb-4 pr-9" },
              props.node.title,
            ),
            React.createElement("div", {
              className: "dt-body",
              dangerouslySetInnerHTML: { __html: props.node.content },
            }),
            props.node.files && props.node.files.length > 0
              ? React.createElement(
                  "div",
                  { className: "mt-5 pt-4 border-t border-wt-border" },
                  React.createElement(
                    "div",
                    {
                      className:
                        "text-[0.7rem] uppercase tracking-wider text-wt-muted font-semibold mb-1.5",
                    },
                    "Related Files",
                  ),
                  React.createElement(
                    "code",
                    { className: "text-sm text-wt-file font-mono leading-relaxed" },
                    props.node.files.map(function (f, i) {
                      return React.createElement("span", { key: i }, f, React.createElement("br"));
                    }),
                  ),
                )
              : null,
          ),
        );
      }

      function ZoomControls(props) {
        return React.createElement(
          "div",
          {
            className:
              "fixed bottom-5 left-5 z-20 flex items-center gap-1.5 bg-wt-surface border border-wt-border rounded-lg shadow-xl px-2 py-1.5",
          },
          React.createElement(
            "button",
            {
              onClick: props.onZoomOut,
              className:
                "w-7 h-7 rounded text-wt-muted hover:text-wt-fg hover:bg-wt-raised flex items-center justify-center text-lg transition-colors",
            },
            "\u2212",
          ),
          React.createElement(
            "span",
            {
              ref: props.zoomDisplayRef,
              className: "text-xs text-wt-muted w-12 text-center font-mono",
            },
            "100%",
          ),
          React.createElement(
            "button",
            {
              onClick: props.onZoomIn,
              className:
                "w-7 h-7 rounded text-wt-muted hover:text-wt-fg hover:bg-wt-raised flex items-center justify-center text-lg transition-colors",
            },
            "+",
          ),
          React.createElement(
            "button",
            {
              onClick: props.onFit,
              className:
                "w-7 h-7 rounded text-wt-muted hover:text-wt-fg hover:bg-wt-raised flex items-center justify-center text-xs transition-colors ml-1",
            },
            "Fit",
          ),
        );
      }

      function App() {
        var activeIdState = useState(null);
        var activeId = activeIdState[0];
        var _setActiveId = activeIdState[1];
        var pz = usePanZoom();

        var setActiveNode = useCallback(function (nodeId) {
          _setActiveId(nodeId);
          document.querySelectorAll(".mermaid-wrap .node").forEach(function (n) {
            n.style.opacity = nodeId ? "0.4" : "1";
          });
          if (nodeId) {
            var el = document.querySelector('.mermaid-wrap .node[id*="' + nodeId + '"]');
            if (el) el.style.opacity = "1";
          }
        }, []);

        var closeDetail = useCallback(function () {
          _setActiveId(null);
          document.querySelectorAll(".mermaid-wrap .node").forEach(function (n) {
            n.style.opacity = "1";
          });
        }, []);

        useEffect(
          function () {
            setTimeout(pz.fitToScreen, 600);
          },
          [pz.fitToScreen],
        );

        return React.createElement(
          React.Fragment,
          null,
          React.createElement(
            "header",
            {
              className:
                "fixed top-0 inset-x-0 z-10 px-6 py-3.5 bg-gradient-to-b from-wt-bg to-transparent pointer-events-none",
            },
            React.createElement(
              "h1",
              { className: "text-base font-semibold text-wt-fg" },
              "Arrow Tool \u2014 Complete Flow",
            ),
            React.createElement(
              "p",
              { className: "text-sm text-wt-muted mt-0.5" },
              "From toolbar click to canvas rendering: activation, drawing, multi-point, angle snapping, and arrowhead math",
            ),
          ),
          React.createElement(
            "div",
            {
              ref: pz.viewportRef,
              className: "w-full h-screen overflow-hidden cursor-grab active:cursor-grabbing",
            },
            React.createElement(
              "div",
              {
                ref: pz.canvasRef,
                className: "origin-top-left will-change-transform inline-block p-[80px_60px_60px]",
              },
              React.createElement(MermaidDiagram, { onNodeClick: setActiveNode }),
            ),
          ),
          React.createElement(ZoomControls, {
            zoomDisplayRef: pz.zoomDisplayRef,
            onZoomIn: pz.zoomIn,
            onZoomOut: pz.zoomOut,
            onFit: pz.fitToScreen,
          }),
          React.createElement(
            "div",
            {
              className:
                "fixed bottom-5 left-1/2 -translate-x-1/2 z-20 flex gap-4 px-4 py-2 bg-wt-surface border border-wt-border rounded-lg shadow-xl",
            },
            LEGEND.map(function (l) {
              return React.createElement(
                "span",
                {
                  key: l.label,
                  className: "flex items-center gap-1.5 text-xs text-wt-muted",
                },
                React.createElement("span", { className: "w-2 h-2 rounded-full " + l.color }),
                l.label,
              );
            }),
          ),
          activeId && NODES[activeId]
            ? React.createElement(DetailPanel, { node: NODES[activeId], onClose: closeDetail })
            : null,
          React.createElement(
            "div",
            {
              className: "fixed bottom-5 right-5 z-20 text-xs text-wt-muted opacity-50",
            },
            React.createElement("kbd", null, "Scroll"),
            " zoom \u00b7 ",
            React.createElement("kbd", null, "Drag"),
            " pan \u00b7 Click nodes",
          ),
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(React.createElement(App));
    </script>
  </body>
</html>

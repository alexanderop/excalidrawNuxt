<!DOCTYPE html>
<html lang="en" style="color-scheme:dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rectangle Creation Flow — ExcalidrawNuxt</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            wt: {
              bg: '#000000', surface: '#0a0a0a', raised: '#141414',
              border: '#2a2a2a', fg: '#ffffff', muted: '#a0a0a0',
              accent: '#a855f7', file: '#c084fc', red: '#ef4444',
            },
            node: {
              component: '#a855f7', composable: '#7c3aed', utility: '#6d28d9',
              external: '#525252', event: '#d8b4fe', data: '#9333ea',
            },
          },
        },
      },
    };
  </script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
  <style>
    .mermaid-wrap svg { max-width: none !important; height: auto !important; }
    .mermaid-wrap .node { cursor: pointer; }
    .mermaid-wrap .node:hover rect,
    .mermaid-wrap .node:hover polygon,
    .mermaid-wrap .node:hover circle,
    .mermaid-wrap .node:hover .label-container {
      filter: brightness(1.3); transition: filter .15s;
    }
    .dt-body p { color:#a0a0a0; font-size:.88rem; line-height:1.65; margin-bottom:10px; }
    .dt-body p code {
      background:rgba(168,85,247,.12); padding:1px 6px; border-radius:4px;
      font-family:'SF Mono','Fira Code',monospace; font-size:.82rem; color:#c084fc;
    }
    .dt-body .shiki {
      background: #000000 !important;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 14px 16px;
      overflow-x: auto;
      margin: 8px 0 14px;
    }
    .dt-body .shiki code {
      font-family: 'SF Mono','Fira Code',monospace;
      font-size: .78rem;
      line-height: 1.55;
      background: none;
      padding: 0;
      border-radius: 0;
      color: inherit;
    }
    .dt-body pre.code-fallback {
      background: #000000;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 14px 16px;
      overflow-x: auto;
      margin: 8px 0 14px;
    }
    .dt-body pre.code-fallback code {
      font-family: 'SF Mono','Fira Code',monospace;
      font-size: .78rem;
      line-height: 1.55;
      color: #e0e0e0;
      background: none;
      padding: 0;
      border-radius: 0;
    }
  </style>
</head>
<body class="bg-wt-bg text-wt-fg m-0 overflow-hidden">
  <div id="root"></div>

  <script type="module">
import { createHighlighter } from 'https://cdn.jsdelivr.net/npm/shiki@3.22.0/+esm'

const { useState, useEffect, useRef, useCallback } = React;

const SUMMARY = "When you select the rectangle tool and drag on the canvas, a chain of state flows through CanvasContainer. The tool store sets the active tool, useDrawingInteraction captures pointer events to create and mutate an element, useElements stores it permanently, and the three-layer rendering pipeline paints it to canvas via roughjs.";

const DIAGRAM = `graph TD
  subgraph user_input["User Input"]
    toolSelect["Tool Selection"]:::event
    pointerEvents["Pointer Events"]:::event
  end

  subgraph orchestration["CanvasContainer Orchestration"]
    canvasContainer["Canvas Container"]:::component
    toolStore["Tool Store"]:::data
    dirtyFlags["Dirty Flag Callbacks"]:::utility
  end

  subgraph element_lifecycle["Element Lifecycle"]
    drawingInteraction["Drawing Interaction"]:::composable
    createElement["Element Factory"]:::utility
    elementsStore["Elements Store"]:::data
    mutateElement["Element Mutation"]:::utility
  end

  subgraph rendering["Rendering Pipeline"]
    sceneRenderer["Scene Renderer"]:::composable
    shapeGenerator["Shape Generator + Cache"]:::utility
    roughjs["Roughjs Canvas Drawing"]:::external
  end

  toolSelect -->|"sets active tool"| toolStore
  toolStore -->|"guards interaction"| drawingInteraction
  canvasContainer -->|"wires pointer events"| drawingInteraction
  pointerEvents -->|"pointerdown"| drawingInteraction
  drawingInteraction -->|"calls on pointerdown"| createElement
  createElement -->|"returns new element"| drawingInteraction
  drawingInteraction -->|"updates on pointermove"| mutateElement
  drawingInteraction -->|"adds on pointerup"| elementsStore
  drawingInteraction -->|"marks layers dirty"| dirtyFlags
  dirtyFlags -->|"schedules rAF"| sceneRenderer
  elementsStore -->|"feeds elements"| sceneRenderer
  sceneRenderer -->|"generates drawables"| shapeGenerator
  shapeGenerator -->|"renders to canvas"| roughjs

  classDef component fill:#a855f7,stroke:#c084fc,color:#fff
  classDef composable fill:#7c3aed,stroke:#a78bfa,color:#fff
  classDef utility fill:#6d28d9,stroke:#8b5cf6,color:#fff
  classDef external fill:#525252,stroke:#737373,color:#fff
  classDef event fill:#d8b4fe,stroke:#e9d5ff,color:#000
  classDef data fill:#9333ea,stroke:#a855f7,color:#fff

  click toolSelect nodeClickHandler "View details"
  click pointerEvents nodeClickHandler "View details"
  click canvasContainer nodeClickHandler "View details"
  click toolStore nodeClickHandler "View details"
  click dirtyFlags nodeClickHandler "View details"
  click drawingInteraction nodeClickHandler "View details"
  click createElement nodeClickHandler "View details"
  click elementsStore nodeClickHandler "View details"
  click mutateElement nodeClickHandler "View details"
  click sceneRenderer nodeClickHandler "View details"
  click shapeGenerator nodeClickHandler "View details"
  click roughjs nodeClickHandler "View details"
`;

const NODES = {
  toolSelect: {
    title: "Tool Selection",
    description: "The user picks the rectangle tool via the DrawingToolbar button or by pressing the 'r' keyboard shortcut. This fires setTool('rectangle') on the global tool store, which emits an onBeforeToolChange event (used by CanvasContainer to clean up prior interactions) and updates the activeTool ref.",
    files: ["app/features/tools/components/DrawingToolbar.vue"],
  },
  pointerEvents: {
    title: "Pointer Events on Canvas",
    description: "The interactive canvas (topmost of three stacked canvases, z-index 2) receives all pointer events. CanvasContainer wires pointerdown, pointermove, and pointerup to the useDrawingInteraction composable via useEventListener. The static and new-element canvases have pointer-events-none.",
    files: ["app/features/canvas/components/CanvasContainer.vue"],
  },
  canvasContainer: {
    title: "Canvas Container",
    description: "The central orchestrator component. Initializes 8+ composables (viewport, elements, tools, selection, drawing, panning, rendering), creates three canvas layers, and wires them together. It pre-creates shared shallowRefs (newElement, selectionBox) and deferred dirty callbacks to break circular dependencies between composables.",
    files: ["app/features/canvas/components/CanvasContainer.vue"],
    code: `const newElement = shallowRef<ExcalidrawElement | null>(null)
const dirtyCallbacks = {
  markStaticDirty: () => {},
  markInteractiveDirty: () => {},
}`,
    lang: "typescript",
  },
  toolStore: {
    title: "Tool Store (Global State)",
    description: "A VueUse createGlobalState composable that holds the activeTool as a shallowRef. Shared across all components — toolbar reads it for highlighting, drawing interaction reads it to decide whether to handle pointer events. Also listens to document keydown for tool shortcuts (r, o, d, a, 1-5).",
    files: ["app/features/tools/useTool.ts"],
    code: `export const useToolStore = createGlobalState(() => {
  const activeTool = shallowRef<ToolType>('selection')
  const { on: onBeforeToolChange, trigger } = createEventHook<void>()
})`,
    lang: "typescript",
  },
  dirtyFlags: {
    title: "Dirty Flag Callbacks",
    description: "Three functions — markStaticDirty, markNewElementDirty, markInteractiveDirty — that schedule canvas repaints on the next requestAnimationFrame. They are created by useRenderer inside useSceneRenderer, then backfilled into a deferred object so that upstream composables (drawing, selection) can call them without circular imports.",
    files: ["app/features/canvas/composables/useRenderer.ts", "app/features/canvas/composables/useSceneRenderer.ts"],
  },
  drawingInteraction: {
    title: "Drawing Interaction",
    description: "The core composable for shape creation. On pointerdown: checks isDrawingTool(activeTool), creates a new element at the click position, captures the pointer. On pointermove: mutates the element's width/height (with shift-key square constraint for shapes). On pointerup: validates the element is large enough, adds it to the elements store, selects it, and auto-switches back to the selection tool.",
    files: ["app/features/tools/useDrawingInteraction.ts"],
    code: `// pointerdown
newElement.value = createElement(tool, originX, originY)
// pointermove
mutateElement(el, { x, y, width, height })
// pointerup
onElementCreated(el)
setTool('selection')`,
    lang: "typescript",
  },
  createElement: {
    title: "Element Factory",
    description: "Pure function that creates an ExcalidrawElement with a unique ID, seed for deterministic roughjs randomness, and default styling (stroke #1e1e1e, hachure fill, roughness 1). For rectangles, it returns { ...base, type: 'rectangle' } with width and height initially at 0 — these get updated during pointermove.",
    files: ["app/features/elements/createElement.ts"],
    code: `const base = { id: generateId(), x, y, width: 0, height: 0,
  strokeColor: DEFAULT_STROKE_COLOR, seed: randomInteger() }
if (type === 'rectangle') return { ...base, type }`,
    lang: "typescript",
  },
  elementsStore: {
    title: "Elements Store",
    description: "A composable that stores all drawn elements in a shallowRef array. addElement() spreads the existing array with the new element (immutable replacement) and also inserts into a Map for O(1) lookups by ID. This triggers Vue reactivity, which the scene renderer watches to know when to repaint the static layer.",
    files: ["app/features/elements/useElements.ts"],
    code: `function addElement(element: ExcalidrawElement): void {
  elements.value = [...elements.value, element]
  elementMap.set(element.id, element)
}`,
    lang: "typescript",
  },
  mutateElement: {
    title: "Element Mutation",
    description: "Updates element properties in-place via Object.assign() and bumps versionNonce to invalidate the shape cache. This is called on every pointermove during drawing to update x, y, width, height. The versionNonce change tells shapeGenerator to regenerate the roughjs drawable for the next render frame.",
    files: ["app/features/elements/mutateElement.ts"],
    code: `Object.assign(element, updates, {
  versionNonce: randomVersionNonce()
})`,
    lang: "typescript",
  },
  sceneRenderer: {
    title: "Scene Renderer",
    description: "Orchestrates three canvas layers via useRenderer. When a dirty flag is set, it schedules a single requestAnimationFrame that checks all three flags and repaints only the dirty layers. During drawing, the new-element layer repaints on each move (cheap — one shape), while the static layer only repaints when the element is finalized.",
    files: ["app/features/canvas/composables/useSceneRenderer.ts", "app/features/canvas/composables/useRenderer.ts"],
  },
  shapeGenerator: {
    title: "Shape Generator + Cache",
    description: "Converts an ExcalidrawElement into a roughjs Drawable. For rectangles: calls generator.rectangle(0, 0, width, height, options). Caches drawables keyed by element ID + versionNonce — if the nonce hasn't changed, returns the cached drawable instantly. This makes static layer repaints fast when only selection changes.",
    files: ["app/features/rendering/shapeGenerator.ts"],
    code: `const cached = shapeCache.get(element.id)
if (cached?.nonce === element.versionNonce) return cached.drawable
const drawable = generator.rectangle(0, 0, width, height, options)
shapeCache.set(element.id, { nonce: element.versionNonce, drawable })`,
    lang: "typescript",
  },
  roughjs: {
    title: "Roughjs Canvas Drawing",
    description: "External library that renders hand-drawn/sketchy shapes on HTML canvas. RoughCanvas.draw() takes a Drawable and paints strokes with controlled randomness (seeded for determinism). The element's seed ensures the same rectangle always looks identical across re-renders.",
    files: ["app/features/rendering/renderElement.ts"],
  },
};

const LEGEND = [
  { label: 'Event', color: 'bg-node-event' },
  { label: 'Component', color: 'bg-node-component' },
  { label: 'Composable', color: 'bg-node-composable' },
  { label: 'Data Store', color: 'bg-node-data' },
  { label: 'Utility', color: 'bg-node-utility' },
  { label: 'External', color: 'bg-node-external' },
];

// Shiki init
const langs = [...new Set(Object.values(NODES).map(n => n.lang).filter(Boolean))];
if (langs.length === 0) langs.push('typescript');

let highlighter = null;
try {
  highlighter = await createHighlighter({ themes: ['vitesse-dark'], langs });
} catch (e) {
  console.warn('Shiki failed to load:', e);
}

const HIGHLIGHTED = {};
for (const [id, node] of Object.entries(NODES)) {
  if (node.code && highlighter) {
    try {
      HIGHLIGHTED[id] = highlighter.codeToHtml(node.code, {
        lang: node.lang || 'typescript',
        theme: 'vitesse-dark',
      });
    } catch (e) { console.warn(`Highlight failed for ${id}:`, e); }
  }
}

// --- React Components (createElement, no JSX) ---
const h = React.createElement;

function usePanZoom() {
  const viewportRef = useRef(null);
  const canvasRef = useRef(null);
  const zoomDisplayRef = useRef(null);
  const st = useRef({ zoom: 1, panX: 0, panY: 0 });
  const drag = useRef({ on: false, lx: 0, ly: 0 });

  const apply = useCallback(() => {
    const { zoom, panX, panY } = st.current;
    if (canvasRef.current)
      canvasRef.current.style.transform = `translate(${panX}px,${panY}px) scale(${zoom})`;
    if (zoomDisplayRef.current)
      zoomDisplayRef.current.textContent = Math.round(zoom * 100) + '%';
  }, []);

  const fitToScreen = useCallback(() => {
    const svg = canvasRef.current?.querySelector('svg');
    const vp = viewportRef.current;
    if (!svg || !vp) return;
    const s = st.current;
    const vw = vp.clientWidth, vh = vp.clientHeight;
    const sw = svg.getBoundingClientRect().width / s.zoom;
    const sh = svg.getBoundingClientRect().height / s.zoom;
    const fit = Math.max(0.15, Math.min(2, Math.min((vw - 80) / sw, (vh - 80) / sh)));
    s.zoom = fit;
    s.panX = (vw - sw * fit) / 2;
    s.panY = (vh - sh * fit) / 2;
    apply();
  }, [apply]);

  useEffect(() => {
    const vp = viewportRef.current;
    if (!vp) return;

    const onWheel = (e) => {
      e.preventDefault();
      const r = vp.getBoundingClientRect();
      const mx = e.clientX - r.left, my = e.clientY - r.top;
      const s = st.current;
      const f = e.deltaY < 0 ? 1.12 : 1 / 1.12;
      const nz = Math.min(4, Math.max(0.15, s.zoom * f));
      const sc = nz / s.zoom;
      s.panX = mx - sc * (mx - s.panX);
      s.panY = my - sc * (my - s.panY);
      s.zoom = nz;
      apply();
    };

    const onDown = (e) => {
      if (e.target.closest('.node')) return;
      drag.current = { on: true, lx: e.clientX, ly: e.clientY };
      vp.setPointerCapture(e.pointerId);
    };
    const onMove = (e) => {
      const d = drag.current;
      if (!d.on) return;
      st.current.panX += e.clientX - d.lx;
      st.current.panY += e.clientY - d.ly;
      d.lx = e.clientX; d.ly = e.clientY;
      apply();
    };
    const onUp = () => { drag.current.on = false; };

    vp.addEventListener('wheel', onWheel, { passive: false });
    vp.addEventListener('pointerdown', onDown);
    vp.addEventListener('pointermove', onMove);
    vp.addEventListener('pointerup', onUp);
    vp.addEventListener('pointercancel', onUp);
    window.addEventListener('resize', fitToScreen);

    return () => {
      vp.removeEventListener('wheel', onWheel);
      vp.removeEventListener('pointerdown', onDown);
      vp.removeEventListener('pointermove', onMove);
      vp.removeEventListener('pointerup', onUp);
      vp.removeEventListener('pointercancel', onUp);
      window.removeEventListener('resize', fitToScreen);
    };
  }, [apply, fitToScreen]);

  const zoomIn = useCallback(() => { st.current.zoom = Math.min(4, st.current.zoom * 1.25); apply(); }, [apply]);
  const zoomOut = useCallback(() => { st.current.zoom = Math.max(0.15, st.current.zoom / 1.25); apply(); }, [apply]);

  return { viewportRef, canvasRef, zoomDisplayRef, zoomIn, zoomOut, fitToScreen };
}

function MermaidDiagram({ onNodeClick }) {
  const ref = useRef(null);

  useEffect(() => {
    window.nodeClickHandler = onNodeClick;
    mermaid.initialize({
      startOnLoad: false,
      theme: 'dark',
      themeVariables: {
        primaryColor: '#0a0a0a',
        primaryTextColor: '#ffffff',
        primaryBorderColor: '#2a2a2a',
        lineColor: '#a0a0a0',
        secondaryColor: '#000000',
        tertiaryColor: '#000000',
        background: '#000000',
        mainBkg: '#0a0a0a',
        nodeBorder: '#2a2a2a',
        clusterBkg: 'rgba(10,10,10,0.8)',
        clusterBorder: '#7c3aed',
        titleColor: '#ffffff',
        edgeLabelBackground: 'transparent',
      },
      flowchart: { useMaxWidth: false, htmlLabels: true, curve: 'basis' },
      securityLevel: 'loose',
    });
    mermaid.render('walkthrough-diagram', DIAGRAM).then(({ svg, bindFunctions }) => {
      if (ref.current) {
        ref.current.innerHTML = svg;
        bindFunctions?.(ref.current);
      }
    });
    return () => { delete window.nodeClickHandler; };
  }, [onNodeClick]);

  return h('div', { ref, className: 'mermaid-wrap' });
}

function Summary() {
  return h('div', {
    className: 'fixed top-16 left-6 z-10 max-w-lg px-4 py-3 bg-wt-surface/80 backdrop-blur border border-wt-border rounded-lg shadow-lg pointer-events-none'
  },
    h('p', { className: 'text-sm text-wt-muted leading-relaxed' }, SUMMARY)
  );
}

function DetailPanel({ nodeId, node, onClose }) {
  useEffect(() => {
    const onKey = (e) => { if (e.key === 'Escape') onClose(); };
    document.addEventListener('keydown', onKey);
    return () => document.removeEventListener('keydown', onKey);
  }, [onClose]);

  const codeHtml = HIGHLIGHTED[nodeId];

  return h('div', {
    className: 'fixed top-4 right-4 bottom-4 w-[560px] z-30 bg-wt-surface border border-wt-border rounded-xl shadow-2xl flex flex-col overflow-hidden'
  },
    h('button', {
      onClick: onClose,
      className: 'absolute top-3 right-3 z-10 w-7 h-7 rounded-md border border-wt-border bg-wt-raised text-wt-muted flex items-center justify-center text-lg hover:bg-wt-red hover:border-wt-red hover:text-white transition-colors'
    }, '\u00d7'),
    h('div', { className: 'flex-1 overflow-y-auto p-5' },
      h('h2', { className: 'text-lg font-bold text-wt-fg mb-3 pr-9' }, node.title),
      h('div', { className: 'dt-body' },
        h('p', null, node.description)
      ),
      node.code ? h('div', { className: 'dt-body' },
        codeHtml
          ? h('div', { dangerouslySetInnerHTML: { __html: codeHtml } })
          : h('pre', { className: 'code-fallback' }, h('code', null, node.code))
      ) : null,
      node.files && node.files.length > 0 ? h('div', { className: 'mt-4 pt-3 border-t border-wt-border' },
        h('div', { className: 'text-[0.7rem] uppercase tracking-wider text-wt-muted font-semibold mb-1.5' }, 'Files'),
        h('code', { className: 'text-sm text-wt-file font-mono leading-relaxed' },
          node.files.map((f, i) => h('span', { key: i }, f, h('br')))
        )
      ) : null
    )
  );
}

function ZoomControls({ zoomDisplayRef, onZoomIn, onZoomOut, onFit }) {
  return h('div', {
    className: 'fixed bottom-5 left-5 z-20 flex flex-col gap-1'
  },
    h('button', { onClick: onZoomIn, className: 'w-8 h-8 rounded-md bg-wt-surface border border-wt-border text-wt-fg hover:bg-wt-raised transition-colors text-sm font-bold' }, '+'),
    h('div', { ref: zoomDisplayRef, className: 'text-[10px] text-wt-muted text-center py-0.5' }, '100%'),
    h('button', { onClick: onZoomOut, className: 'w-8 h-8 rounded-md bg-wt-surface border border-wt-border text-wt-fg hover:bg-wt-raised transition-colors text-sm font-bold' }, '\u2212'),
    h('button', { onClick: onFit, className: 'w-8 h-8 rounded-md bg-wt-surface border border-wt-border text-wt-muted hover:bg-wt-raised transition-colors text-[10px] mt-1' }, 'Fit')
  );
}

function App() {
  const [activeId, _setActiveId] = useState(null);
  const pz = usePanZoom();

  const setActiveNode = useCallback((nodeId) => {
    _setActiveId(nodeId);
    document.querySelectorAll('.mermaid-wrap .node').forEach(n => { n.style.opacity = nodeId ? '0.4' : '1'; });
    if (nodeId) {
      const el = document.querySelector(`.mermaid-wrap .node[id*="${nodeId}"]`);
      if (el) el.style.opacity = '1';
    }
  }, []);

  const closeDetail = useCallback(() => {
    _setActiveId(null);
    document.querySelectorAll('.mermaid-wrap .node').forEach(n => { n.style.opacity = '1'; });
  }, []);

  useEffect(() => { setTimeout(pz.fitToScreen, 600); }, [pz.fitToScreen]);

  return h(React.Fragment, null,
    h('header', {
      className: 'fixed top-0 inset-x-0 z-10 px-6 py-3.5 bg-gradient-to-b from-wt-bg to-transparent pointer-events-none'
    },
      h('h1', { className: 'text-base font-semibold text-wt-fg' }, 'Rectangle Creation Flow'),
      h('p', { className: 'text-sm text-wt-muted mt-0.5' }, 'State dependencies from CanvasContainer when drawing a rectangle')
    ),

    h(Summary),

    h('div', {
      ref: pz.viewportRef,
      className: 'w-full h-screen overflow-hidden cursor-grab active:cursor-grabbing'
    },
      h('div', {
        ref: pz.canvasRef,
        className: 'origin-top-left will-change-transform inline-block p-[80px_60px_60px]'
      },
        h(MermaidDiagram, { onNodeClick: setActiveNode })
      )
    ),

    h(ZoomControls, {
      zoomDisplayRef: pz.zoomDisplayRef,
      onZoomIn: pz.zoomIn,
      onZoomOut: pz.zoomOut,
      onFit: pz.fitToScreen
    }),

    h('div', {
      className: 'fixed bottom-5 left-1/2 -translate-x-1/2 z-20 flex gap-4 px-4 py-2 bg-wt-surface border border-wt-border rounded-lg shadow-xl'
    },
      LEGEND.map(l => h('span', {
        key: l.label,
        className: 'flex items-center gap-1.5 text-xs text-wt-muted'
      },
        h('span', { className: `w-2 h-2 rounded-full ${l.color}` }),
        l.label
      ))
    ),

    activeId && NODES[activeId] ? h(DetailPanel, {
      nodeId: activeId,
      node: NODES[activeId],
      onClose: closeDetail
    }) : null,

    h('div', {
      className: 'fixed bottom-5 right-5 z-20 text-xs text-wt-muted opacity-50'
    },
      h('kbd', null, 'Scroll'), ' zoom \u00b7 ', h('kbd', null, 'Drag'), ' pan \u00b7 Click nodes'
    )
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(h(App));
  </script>
</body>
</html>

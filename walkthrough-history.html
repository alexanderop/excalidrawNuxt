<!DOCTYPE html>
<html lang="en" style="color-scheme:dark">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>History (Undo/Redo) Walkthrough</title>
<script src="https://cdn.tailwindcss.com"></script>
<script>
tailwind.config = {
  theme: {
    extend: {
      colors: {
        wt: { bg:"#000000", surface:"#0a0a0a", raised:"#141414", border:"#2a2a2a",
              fg:"#ffffff", muted:"#a0a0a0", accent:"#a855f7", file:"#c084fc", red:"#ef4444" },
        node: { component:"#a855f7", composable:"#7c3aed", utility:"#6d28d9",
                external:"#525252", event:"#d8b4fe", data:"#9333ea" },
      },
    },
  },
};
</script>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
<style>
*, *::before, *::after { box-sizing: border-box; }
body { margin:0; background:#000; color:#fff; font-family:system-ui,-apple-system,sans-serif; overflow:hidden; }
.mermaid-wrap { display:flex; justify-content:center; }
.mermaid-wrap svg { max-width:none; height:auto !important; min-width:600px; }
.mermaid-wrap .node { cursor:pointer; transition:filter 0.3s, opacity 0.3s; }
.mermaid-wrap .node:hover rect,
.mermaid-wrap .node:hover polygon,
.mermaid-wrap .node:hover circle,
.mermaid-wrap .node:hover .label-container { filter:brightness(1.3); transition:filter 0.15s; }
.dt-body p { color:#a0a0a0; font-size:0.85rem; line-height:1.6; margin-bottom:8px; }
.dt-body p code { background:rgba(168,85,247,0.12); padding:1px 5px; border-radius:4px; font-family:"SF Mono","Fira Code",monospace; font-size:0.8rem; color:#c084fc; }
.dt-body .shiki { background:#000 !important; border:1px solid #2a2a2a; border-radius:8px; padding:12px 14px; overflow-x:auto; margin:6px 0 12px; }
.dt-body .shiki code { font-family:"SF Mono","Fira Code",monospace; font-size:0.75rem; line-height:1.5; background:none; padding:0; border-radius:0; color:inherit; }
.dt-body pre.code-fallback { background:#000; border:1px solid #2a2a2a; border-radius:8px; padding:12px 14px; overflow-x:auto; margin:6px 0 12px; }
.dt-body pre.code-fallback code { font-family:"SF Mono","Fira Code",monospace; font-size:0.75rem; line-height:1.5; color:#e0e0e0; background:none; padding:0; }

@keyframes cardSlideIn { from { transform:translateY(-10px); opacity:0; } to { transform:translateY(0); opacity:1; } }
@keyframes nodePulse {
  0%,100% { filter:drop-shadow(0 0 6px #a855f7) drop-shadow(0 0 12px rgba(168,85,247,0.4)); }
  50% { filter:drop-shadow(0 0 14px #a855f7) drop-shadow(0 0 28px rgba(168,85,247,0.6)); }
}
@keyframes stepFade { from { opacity:0; transform:translateY(3px); } to { opacity:1; transform:translateY(0); } }
@keyframes cpGlow { 0%,100% { box-shadow:0 0 6px rgba(250,204,21,0.3); } 50% { box-shadow:0 0 14px rgba(250,204,21,0.6); } }
@keyframes detailIn { from { opacity:0; transform:translateY(8px); } to { opacity:1; transform:translateY(0); } }
@keyframes capFlash { 0% { background:rgba(239,68,68,0.2); } 100% { background:transparent; } }

.stack-card { animation:cardSlideIn 0.3s ease-out both; }
.node-highlighted { animation:nodePulse 1s ease-in-out infinite; }
.step-anim { animation:stepFade 0.25s ease-out; }
.cp-glow { animation:cpGlow 1.5s ease-in-out infinite; }
.detail-in { animation:detailIn 0.2s ease-out; }
.cap-flash { animation:capFlash 1s ease-out; }

.sim-btn { padding:5px 12px; border-radius:7px; font-size:0.72rem; font-weight:600; border:1px solid #2a2a2a; background:#141414; color:#a0a0a0; cursor:pointer; transition:all 0.15s; white-space:nowrap; }
.sim-btn:hover:not(:disabled) { background:#1f1f1f; color:#fff; border-color:#a855f7; }
.sim-btn:disabled { opacity:0.25; cursor:not-allowed; }
.sim-btn-accent { background:#7c3aed; color:#fff; border-color:#a855f7; }
.sim-btn-accent:hover:not(:disabled) { background:#9333ea; }
.sim-btn-warn { border-color:#525252; }
.sim-btn-warn:hover:not(:disabled) { border-color:#ef4444; color:#ef4444; }
.sim-btn-next { background:#059669; color:#fff; border-color:#10b981; font-size:0.75rem; padding:4px 14px; }
.sim-btn-next:hover:not(:disabled) { background:#10b981; }
.progress-track { height:3px; background:#2a2a2a; border-radius:2px; overflow:hidden; }
.progress-fill { height:100%; background:#a855f7; border-radius:2px; transition:width 0.3s ease; }
.mode-seg { display:inline-flex; gap:1px; background:#1a1a1a; border-radius:6px; padding:2px; border:1px solid #2a2a2a; }
.mode-seg button { padding:2px 8px; border-radius:4px; font-size:10px; font-weight:600; border:none; cursor:pointer; transition:all 0.15s; color:#a0a0a0; background:transparent; }
.mode-seg button.active { background:#7c3aed; color:#fff; }
.mode-seg button:disabled { opacity:0.3; cursor:not-allowed; }

/* Scrollbar */
::-webkit-scrollbar { width:5px; }
::-webkit-scrollbar-track { background:transparent; }
::-webkit-scrollbar-thumb { background:#2a2a2a; border-radius:3px; }
::-webkit-scrollbar-thumb:hover { background:#525252; }
</style>
</head>
<body class="bg-wt-bg">
<div id="root"></div>

<script type="module">
import { createHighlighter } from 'https://cdn.jsdelivr.net/npm/shiki@3.22.0/+esm';

const { useState, useEffect, useRef, useCallback } = React;
const h = React.createElement;

// ─── Data ───

const DIAGRAM = `graph TD
  subgraph triggers["User Triggers"]
    userAction["User Action"]
    actionRegistry["Action Registry & UI"]
  end

  subgraph capturing["Capturing State"]
    checkpointFlow["Checkpoint Flow"]
    recordAction["Record Action"]
    snapshotCapture["Snapshot Capture"]
    changeDetection["Change Detection"]
  end

  subgraph storage["History Storage"]
    undoRedoStacks["Undo / Redo Stacks"]
  end

  subgraph restoring["Restoring State"]
    undoRedoOps["Undo / Redo Operations"]
    stateRestore["State Restoration"]
    dirtyFlags["Canvas Re-render"]
  end

  userAction -->|"draws, drags, resizes"| checkpointFlow
  userAction -->|"deletes, duplicates, groups"| recordAction
  checkpointFlow -->|"captures before state"| snapshotCapture
  recordAction -->|"captures before state"| snapshotCapture
  snapshotCapture -.->|"compares before vs after"| changeDetection
  changeDetection -->|"if changed, pushes"| undoRedoStacks
  checkpointFlow -.->|"cancel: discardCheckpoint"| stateRestore
  actionRegistry -->|"Cmd+Z / Cmd+Shift+Z"| undoRedoOps
  undoRedoOps -->|"pops & swaps stacks"| undoRedoStacks
  undoRedoOps -->|"replaces elements & selection"| stateRestore
  stateRestore -->|"marks dirty"| dirtyFlags

  classDef component fill:#a855f7,stroke:#c084fc,color:#fff
  classDef composable fill:#7c3aed,stroke:#a78bfa,color:#fff
  classDef utility fill:#6d28d9,stroke:#8b5cf6,color:#fff
  classDef external fill:#525252,stroke:#737373,color:#fff
  classDef event fill:#d8b4fe,stroke:#e9d5ff,color:#000
  classDef data fill:#9333ea,stroke:#a855f7,color:#fff

  class userAction event
  class actionRegistry composable
  class checkpointFlow composable
  class recordAction composable
  class snapshotCapture utility
  class changeDetection utility
  class undoRedoStacks data
  class undoRedoOps composable
  class stateRestore utility
  class dirtyFlags external

  click userAction nodeClickHandler "View details"
  click actionRegistry nodeClickHandler "View details"
  click checkpointFlow nodeClickHandler "View details"
  click recordAction nodeClickHandler "View details"
  click snapshotCapture nodeClickHandler "View details"
  click changeDetection nodeClickHandler "View details"
  click undoRedoStacks nodeClickHandler "View details"
  click undoRedoOps nodeClickHandler "View details"
  click stateRestore nodeClickHandler "View details"
  click dirtyFlags nodeClickHandler "View details"
`;

const NODES = {
  userAction: {
    title: "User Action",
    description: "Any interaction that modifies canvas state \u2014 drawing shapes, dragging, resizing, rotating, editing text, or atomic operations like delete/duplicate. Routes to either checkpoint flow (long interactions) or record action (one-shot ops).",
    files: ["app/features/tools/useDrawingInteraction.ts", "app/features/tools/useFreeDrawInteraction.ts", "app/features/selection/composables/useSelectionInteraction.ts", "app/features/tools/useTextInteraction.ts"],
  },
  actionRegistry: {
    title: "Action Registry & UI",
    description: "Undo/redo registered as ActionDefinition objects with IDs 'history:undo' and 'history:redo'. Provides keyboard shortcuts, enable/disable states, and makes them available to BottomBar buttons, context menu, and command palette.",
    files: ["app/shared/useActionRegistry.ts", "app/features/canvas/components/BottomBar.vue"],
    code: `{\n  id: "history:undo",\n  label: "Undo",\n  icon: "i-lucide-undo-2",\n  kbds: ["meta", "Z"],\n  handler: history.undo,\n  enabled: () => history.canUndo.value,\n}`,
    lang: "typescript",
  },
  checkpointFlow: {
    title: "Checkpoint Flow",
    description: "For long-running interactions (drag, resize, draw, text edit): saveCheckpoint() captures initial state, commitCheckpoint() finalizes when interaction ends. discardCheckpoint() restores state without creating an undo entry (on cancel/Escape). Batches all intermediate mutations into a single undo entry.",
    files: ["app/features/history/useHistory.ts"],
    code: `// Start interaction\nhistory.saveCheckpoint();\n\n// \u2026 user drags/draws/resizes \u2026\n\n// End: commit or cancel\nhistory.commitCheckpoint();   // \u2192 undo entry\nhistory.discardCheckpoint();  // \u2192 rollback, no entry`,
    lang: "typescript",
  },
  recordAction: {
    title: "Record Action",
    description: "For atomic operations (delete, duplicate, group, layer changes, clipboard): captures snapshot before, runs the function, checks if state changed, pushes to undo stack. Redo stack is cleared since a new history branch has started.",
    files: ["app/features/history/useHistory.ts"],
    code: `function recordAction(fn: () => void): void {\n  const before = captureSnapshot(\n    elements.value, selectedIds.value\n  );\n  fn();\n  if (!hasStateChanged(before, elements.value))\n    return;\n  pushUndo(before);\n  redoStack.value = [];\n}`,
    lang: "typescript",
  },
  snapshotCapture: {
    title: "Snapshot Capture",
    description: "Creates an immutable deep copy of canvas state using structuredClone(). Each readonly HistoryEntry contains the full elements array and selected IDs. Deep cloning at capture time means restoreEntry() can pass snapshots directly without re-cloning.",
    files: ["app/features/history/useHistory.ts"],
    code: `function captureSnapshot(\n  elements: readonly ExcalidrawElement[],\n  selectedIds: ReadonlySet<string>,\n): HistoryEntry {\n  return {\n    elements: elements.map(\n      el => structuredClone(el)\n    ),\n    selectedIds: new Set(selectedIds),\n  };\n}`,
    lang: "typescript",
  },
  changeDetection: {
    title: "Change Detection",
    description: "Ordered fast checks that short-circuit on first difference: array length \u2192 element IDs \u2192 version numbers \u2192 x/y positions \u2192 isDeleted flags. Prevents no-op operations from creating empty undo entries.",
    files: ["app/features/history/useHistory.ts"],
    code: `function hasStateChanged(\n  before: HistoryEntry,\n  current: readonly ExcalidrawElement[],\n): boolean {\n  if (before.elements.length !== current.length)\n    return true;\n  for (let i = 0; i < before.elements.length; i++) {\n    if (before.elements[i].id !== current[i].id)\n      return true;\n    if (before.elements[i].version !== current[i].version)\n      return true;\n    if (before.elements[i].x !== current[i].x\n        || before.elements[i].y !== current[i].y)\n      return true;\n    if (before.elements[i].isDeleted\n        !== current[i].isDeleted)\n      return true;\n  }\n  return false;\n}`,
    lang: "typescript",
  },
  undoRedoStacks: {
    title: "Undo / Redo Stacks",
    description: "Two ShallowRef arrays of HistoryEntry snapshots. Undo stack holds past states (capped at 100). Redo stack holds states pushed during undo. New actions clear the redo stack \u2014 can't redo after new changes.",
    files: ["app/features/history/useHistory.ts"],
    code: `const undoStack = shallowRef<HistoryEntry[]>([]);\nconst redoStack = shallowRef<HistoryEntry[]>([]);\nconst MAX_HISTORY = 100;`,
    lang: "typescript",
  },
  undoRedoOps: {
    title: "Undo / Redo Operations",
    description: "undo() pops from undo stack, pushes current state to redo, restores the popped entry. redo() does the reverse. Auto-commits pending checkpoints on undo. Redo is blocked while a checkpoint is active \u2014 prevents confusion during mid-interaction state.",
    files: ["app/features/history/useHistory.ts"],
    code: `function undo(): void {\n  if (pendingCheckpoint) commitCheckpoint();\n  const entry = undoStack.value.pop();\n  if (!entry) return;\n  redoStack.value.push(captureSnapshot(\u2026));\n  restoreEntry(entry);\n}\n\nfunction redo(): void {\n  if (pendingCheckpoint) return; // Blocked!\n  const entry = redoStack.value.pop();\n  if (!entry) return;\n  pushUndo(captureSnapshot(\u2026));\n  restoreEntry(entry);\n}`,
    lang: "typescript",
  },
  stateRestore: {
    title: "State Restoration",
    description: "Applies a HistoryEntry back to the canvas: passes the already-cloned snapshot directly to replaceElements() and replaceSelection(), then signals both canvas layers to repaint. No re-cloning needed because the snapshot is already an isolated deep copy.",
    files: ["app/features/history/useHistory.ts"],
    code: `function restoreEntry(entry: HistoryEntry): void {\n  replaceElements(entry.elements);\n  replaceSelection(new Set(entry.selectedIds));\n  dirty.markStaticDirty();\n  dirty.markInteractiveDirty();\n}`,
    lang: "typescript",
  },
  dirtyFlags: {
    title: "Canvas Re-render",
    description: "Dirty flag system signals both static and interactive canvas layers to repaint. A deferred callback abstraction that keeps history decoupled from the rendering pipeline.",
    files: ["app/features/canvas/composables/createDirtyFlags.ts"],
  },
};

const LEGEND = [
  { label:"Event", color:"bg-node-event" },
  { label:"Composable", color:"bg-node-composable" },
  { label:"Utility", color:"bg-node-utility" },
  { label:"Data Store", color:"bg-node-data" },
  { label:"External", color:"bg-[#525252]" },
];

// ─── Shiki ───
const langs = [...new Set(Object.values(NODES).map(n=>n.lang).filter(Boolean))];
if (!langs.length) langs.push('typescript');
let hl = null;
try { hl = await createHighlighter({themes:['vitesse-dark'],langs}); } catch(e) { console.warn('Shiki load failed:',e); }
const HI = {};
for (const [id,n] of Object.entries(NODES)) {
  if (n.code && hl) try { HI[id]=hl.codeToHtml(n.code,{lang:n.lang||'typescript',theme:'vitesse-dark'}); } catch(e) {}
}

// ─── Simulator helpers ───
const COLORS = ['#a855f7','#7c3aed','#9333ea','#6d28d9','#c084fc','#8b5cf6'];
const cc = id => COLORS[id%COLORS.length];
const SHAPES = ['Rectangle','Ellipse','Diamond','Arrow','Line'];
let si = 0;
const ns = () => SHAPES[si++%SHAPES.length];
const MAX_SIM_HISTORY = 10; // Real impl uses 100; 10 for demo visibility
const capStack = stack => stack.length > MAX_SIM_HISTORY ? stack.slice(-MAX_SIM_HISTORY) : stack;

// ─── Simulator sequences ───

function seqDraw(shape, st) {
  const b = st.elements;
  const bSel = st.selectedLabel;
  return [
    {node:'userAction', text:`User starts drawing a ${shape}`, delay:650},
    {node:'checkpointFlow', text:'saveCheckpoint() \u2014 captures state before interaction', delay:750,
      mut: s=>({...s, pendingCP:{label:`${b} elem`,elements:b}})},
    {node:'snapshotCapture', text:'structuredClone() deep-copies all elements + selection', delay:650},
    {node:'checkpointFlow', text:`Drawing ${shape}\u2026 intermediate mutations, no history entries`, delay:800,
      mut: s=>({...s, elements:s.elements+1, selectedLabel:shape})},
    {node:'checkpointFlow', text:'Mouse released \u2014 commitCheckpoint()', delay:650},
    {node:'changeDetection', text:'hasStateChanged() \u2192 true (new element, version bumped)', delay:650},
    {node:'undoRedoStacks', text:'Push before-snapshot to undo. Clear redo.', delay:550,
      mut: s=>{const ns=capStack([...s.undoStack,{id:s.nid,label:`Draw ${shape}`,elements:b,color:cc(s.nid),selected:bSel}]);
        return {...s,undoStack:ns,redoStack:[],pendingCP:null,nid:s.nid+1,capHit:ns.length<s.undoStack.length+1};}},
    {node:null, text:`Done! ${shape} drawn. Selected: ${shape}. Undo: ${st.undoStack.length+1} entries.`, delay:0},
  ];
}

function seqMove(st) {
  const b = st.elements;
  const bSel = st.selectedLabel;
  return [
    {node:'userAction', text:`User starts dragging ${bSel||'an element'}`, delay:650},
    {node:'checkpointFlow', text:'saveCheckpoint() \u2014 captures positions before drag', delay:750,
      mut: s=>({...s, pendingCP:{label:`${b} elem`,elements:b}})},
    {node:'snapshotCapture', text:'structuredClone() copies positions, versions, selection', delay:650},
    {node:'checkpointFlow', text:'Dragging\u2026 x/y update every frame (no entries)', delay:800},
    {node:'checkpointFlow', text:'Mouse released \u2014 commitCheckpoint()', delay:650},
    {node:'changeDetection', text:'hasStateChanged() \u2192 true (x/y differ)', delay:650},
    {node:'undoRedoStacks', text:'Push before-snapshot to undo. Clear redo.', delay:550,
      mut: s=>{const ns=capStack([...s.undoStack,{id:s.nid,label:'Move',elements:b,color:cc(s.nid),selected:bSel}]);
        return {...s,undoStack:ns,redoStack:[],pendingCP:null,nid:s.nid+1,capHit:ns.length<s.undoStack.length+1};}},
    {node:null, text:'Done! Move batched as one undo entry.', delay:0},
  ];
}

function seqDelete(st) {
  const b = st.elements;
  const bSel = st.selectedLabel;
  return [
    {node:'userAction', text:`User presses Delete (removing ${bSel||'element'})`, delay:650},
    {node:'recordAction', text:'recordAction() \u2014 captures snapshot BEFORE executing', delay:750},
    {node:'snapshotCapture', text:'structuredClone() deep-copies current state + selection', delay:650},
    {node:'recordAction', text:`Delete executes \u2014 ${bSel||'element'} removed`, delay:650,
      mut: s=>({...s, elements:Math.max(0,s.elements-1), selectedLabel:null})},
    {node:'changeDetection', text:'hasStateChanged() \u2192 true (element count changed)', delay:650},
    {node:'undoRedoStacks', text:'Push before-snapshot to undo. Clear redo.', delay:550,
      mut: s=>{const ns=capStack([...s.undoStack,{id:s.nid,label:`Del ${bSel||'el'}`,elements:b,color:cc(s.nid),selected:bSel}]);
        return {...s,undoStack:ns,redoStack:[],nid:s.nid+1,capHit:ns.length<s.undoStack.length+1};}},
    {node:null, text:`Deleted! Canvas: ${b-1} elements. Selection cleared.`, delay:0},
  ];
}

function seqDuplicate(st) {
  const b = st.elements;
  const bSel = st.selectedLabel;
  const dupName = bSel ? bSel+' copy' : 'Element copy';
  return [
    {node:'userAction', text:`User duplicates ${bSel||'selected element'} (\u2318D)`, delay:650},
    {node:'recordAction', text:'recordAction() \u2014 captures snapshot BEFORE executing', delay:750},
    {node:'snapshotCapture', text:'structuredClone() deep-copies current state + selection', delay:650},
    {node:'recordAction', text:`Duplicate executes \u2014 ${dupName} added`, delay:650,
      mut: s=>({...s, elements:s.elements+1, selectedLabel:dupName})},
    {node:'changeDetection', text:'hasStateChanged() \u2192 true (new element)', delay:650},
    {node:'undoRedoStacks', text:'Push before-snapshot to undo. Clear redo.', delay:550,
      mut: s=>{const ns=capStack([...s.undoStack,{id:s.nid,label:`Dup ${bSel||'el'}`,elements:b,color:cc(s.nid),selected:bSel}]);
        return {...s,undoStack:ns,redoStack:[],nid:s.nid+1,capHit:ns.length<s.undoStack.length+1};}},
    {node:null, text:`Done! ${bSel||'Element'} duplicated. Canvas: ${b+1} elements.`, delay:0},
  ];
}

function seqCancel(st) {
  const b = st.elements;
  const bSel = st.selectedLabel;
  return [
    {node:'userAction', text:`User starts dragging ${bSel||'an element'}`, delay:650},
    {node:'checkpointFlow', text:'saveCheckpoint() \u2014 captures state before drag', delay:750,
      mut: s=>({...s, pendingCP:{label:`${b} elem`,elements:b}})},
    {node:'snapshotCapture', text:'structuredClone() copies positions, versions, selection', delay:650},
    {node:'checkpointFlow', text:'Dragging\u2026 positions change every frame', delay:800},
    {node:'checkpointFlow', text:'User presses Escape \u2014 discardCheckpoint()', delay:750,
      mut: s=>({...s, pendingCP:null})},
    {node:'stateRestore', text:'restoreEntry(checkpoint) \u2014 rollback to pre-drag state', delay:650},
    {node:'dirtyFlags', text:'markStaticDirty() + markInteractiveDirty() \u2192 repaint', delay:550},
    {node:null, text:'Cancelled! State restored to before drag. No undo entry created.', delay:0},
  ];
}

function seqUndo(st) {
  const top = st.undoStack[st.undoStack.length-1];
  if (!top) return [];
  return [
    {node:'actionRegistry', text:'User presses \u2318Z or clicks undo', delay:650},
    {node:'undoRedoOps', text:'undo() \u2014 auto-commits pending checkpoint if any', delay:650},
    {node:'snapshotCapture', text:`Capture current (${st.elements} el) \u2192 push to redo`, delay:650,
      mut: s=>({...s, redoStack:[...s.redoStack,{id:s.nid,label:top.label,elements:s.elements,color:top.color,selected:s.selectedLabel}], nid:s.nid+1})},
    {node:'undoRedoStacks', text:`Pop "${top.label}" from undo (${top.elements} el)`, delay:650,
      mut: s=>({...s, undoStack:s.undoStack.slice(0,-1), elements:top.elements, selectedLabel:top.selected})},
    {node:'stateRestore', text:'restoreEntry() \u2014 replace elements & selection', delay:650},
    {node:'dirtyFlags', text:'markStaticDirty() + markInteractiveDirty() \u2192 repaint', delay:550},
    {node:null, text:`Undone! Canvas: ${top.elements} el. Selection: ${top.selected||'none'}. Redo available.`, delay:0},
  ];
}

function seqRedo(st) {
  const top = st.redoStack[st.redoStack.length-1];
  if (!top) return [];
  return [
    {node:'actionRegistry', text:'User presses \u2318\u21E7Z or clicks redo', delay:650},
    {node:'undoRedoOps', text:'redo() \u2014 blocked if checkpoint active', delay:650},
    {node:'snapshotCapture', text:`Capture current (${st.elements} el) \u2192 push to undo`, delay:650,
      mut: s=>({...s, undoStack:capStack([...s.undoStack,{id:s.nid,label:top.label,elements:s.elements,color:top.color,selected:s.selectedLabel}]), nid:s.nid+1})},
    {node:'undoRedoStacks', text:`Pop "${top.label}" from redo (${top.elements} el)`, delay:650,
      mut: s=>({...s, redoStack:s.redoStack.slice(0,-1), elements:top.elements, selectedLabel:top.selected})},
    {node:'stateRestore', text:'restoreEntry() \u2014 replace elements & selection', delay:650},
    {node:'dirtyFlags', text:'Dirty flags \u2192 canvas repaints', delay:550},
    {node:null, text:`Redone! Canvas: ${top.elements} el. Selection: ${top.selected||'none'}.`, delay:0},
  ];
}

// ─── Diagram highlight helper ───
function hlNode(nodeId) {
  document.querySelectorAll('.mermaid-wrap .node').forEach(n => {
    n.classList.remove('node-highlighted');
    n.style.opacity = nodeId ? '0.2' : '1';
  });
  if (nodeId) {
    const el = document.querySelector(`.mermaid-wrap .node[id*="${nodeId}"]`);
    if (el) { el.classList.add('node-highlighted'); el.style.opacity = '1'; }
  }
}

// ─── Components ───

function MermaidDiagram({onNodeClick}) {
  const ref = useRef(null);
  useEffect(() => {
    window.nodeClickHandler = onNodeClick;
    mermaid.initialize({
      startOnLoad:false, theme:'dark',
      themeVariables: {
        primaryColor:'#0a0a0a', primaryTextColor:'#ffffff', primaryBorderColor:'#2a2a2a',
        lineColor:'#a0a0a0', secondaryColor:'#000000', tertiaryColor:'#000000',
        background:'#000000', mainBkg:'#0a0a0a', nodeBorder:'#2a2a2a',
        clusterBkg:'rgba(10,10,10,0.8)', clusterBorder:'#7c3aed',
        titleColor:'#ffffff', edgeLabelBackground:'transparent',
      },
      flowchart:{useMaxWidth:false, htmlLabels:true, curve:'basis'},
      securityLevel:'loose',
    });
    mermaid.render('wt-diagram',DIAGRAM).then(({svg,bindFunctions})=>{
      if(ref.current){ref.current.innerHTML=svg; bindFunctions?.(ref.current);}
    });
    return ()=>{delete window.nodeClickHandler;};
  },[onNodeClick]);
  return h('div',{ref,className:'mermaid-wrap'});
}

function StackCard({entry}) {
  return h('div',{
    className:'stack-card flex flex-col gap-0.5 px-2.5 py-1.5 rounded-md border border-wt-border/60 text-xs font-mono',
    style:{background:entry.color+'18', borderLeftColor:entry.color, borderLeftWidth:'3px'},
  },
    h('div',{className:'flex items-center gap-2'},
      h('span',{className:'w-1.5 h-1.5 rounded-full flex-shrink-0',style:{background:entry.color}}),
      h('span',{className:'text-wt-fg truncate flex-1'},entry.label),
      h('span',{className:'text-wt-muted text-[10px] flex-shrink-0'},entry.elements+' el'),
    ),
    entry.selected != null
      ? h('div',{className:'text-[9px] text-wt-accent/50 pl-3.5 truncate'},'\u25CB sel: '+entry.selected)
      : null,
  );
}

function DetailOverlay({nodeId, node, onClose}) {
  useEffect(()=>{
    const k=e=>{if(e.key==='Escape')onClose();};
    document.addEventListener('keydown',k);
    return ()=>document.removeEventListener('keydown',k);
  },[onClose]);
  const code = HI[nodeId];
  return h('div',{className:'absolute inset-0 z-30 bg-wt-bg/80 backdrop-blur-sm flex items-start justify-center p-6 overflow-auto',onClick:e=>{if(e.target===e.currentTarget)onClose();}},
    h('div',{className:'detail-in max-w-lg w-full bg-wt-surface border border-wt-border rounded-xl shadow-2xl overflow-hidden'},
      h('div',{className:'flex items-center justify-between px-5 pt-4 pb-2'},
        h('h3',{className:'text-base font-bold text-wt-fg'},node.title),
        h('button',{onClick:onClose,className:'w-6 h-6 rounded-md border border-wt-border bg-wt-raised text-wt-muted flex items-center justify-center text-sm hover:bg-wt-red hover:border-wt-red hover:text-white transition-colors'},'\u00D7'),
      ),
      h('div',{className:'px-5 pb-4'},
        h('div',{className:'dt-body'},h('p',null,node.description)),
        node.code ? h('div',{className:'dt-body'},
          code ? h('div',{dangerouslySetInnerHTML:{__html:code}}) : h('pre',{className:'code-fallback'},h('code',null,node.code))
        ) : null,
        node.files?.length ? h('div',{className:'mt-3 pt-3 border-t border-wt-border'},
          h('div',{className:'text-[10px] uppercase tracking-wider text-wt-muted font-semibold mb-1'},'Files'),
          h('code',{className:'text-xs text-wt-file font-mono leading-relaxed'},
            ...node.files.map((f,i)=>h('span',{key:i},f,h('br'))))
        ) : null,
      ),
    )
  );
}

function Simulator() {
  const INIT = {undoStack:[],redoStack:[],elements:0,selectedLabel:null,pendingCP:null,nid:1,capHit:false};
  const [state,setState] = useState(INIT);
  const [anim,setAnim] = useState({running:false,steps:[],stepIdx:-1,stepText:'Click an action to see the flow step by step',total:0});
  const [mode,setMode] = useState('auto'); // 'auto' | 'step'
  const sRef=useRef(state); sRef.current=state;
  const aRef=useRef(anim); aRef.current=anim;
  const modeRef=useRef(mode); modeRef.current=mode;
  const tRef=useRef(null);
  useEffect(()=>()=>{if(tRef.current)clearTimeout(tRef.current);},[]);

  // Keyboard: Space/Right advances in step mode
  const advanceStep = useCallback(()=>{
    const a=aRef.current;
    if(!a.running) return;
    const ni=a.stepIdx+1;
    if(ni>=a.steps.length){
      setAnim(a=>({...a,running:false,stepIdx:a.total-1}));
      hlNode(null);
      return;
    }
    const step=a.steps[ni];
    setAnim(a=>({...a,stepIdx:ni,stepText:step.text}));
    hlNode(step.node);
    if(step.mut) setState(s=>step.mut(s));
    if(ni>=a.steps.length-1){
      setAnim(a=>({...a,running:false,stepIdx:ni}));
      hlNode(null);
    }
  },[]);

  useEffect(()=>{
    const handler=e=>{
      if((e.key===' '||e.key==='ArrowRight') && modeRef.current==='step' && aRef.current.running){
        e.preventDefault();
        advanceStep();
      }
    };
    document.addEventListener('keydown',handler);
    return ()=>document.removeEventListener('keydown',handler);
  },[advanceStep]);

  // Resume auto-play when switching from step to auto mid-sequence
  useEffect(()=>{
    modeRef.current=mode;
    if(mode==='auto' && aRef.current.running){
      const a=aRef.current;
      let i=a.stepIdx+1;
      function next(){
        if(i>=a.steps.length){setAnim(a=>({...a,running:false,stepIdx:a.steps.length-1}));hlNode(null);return;}
        const step=a.steps[i];
        setAnim(a=>({...a,stepIdx:i,stepText:step.text}));
        hlNode(step.node);
        if(step.mut) setState(s=>step.mut(s));
        i++;
        tRef.current=setTimeout(next,step.delay||650);
      }
      tRef.current=setTimeout(next,200);
    }
  },[mode]);

  const run = useCallback((steps)=>{
    if(aRef.current.running||!steps.length) return;
    setState(s=>({...s,capHit:false}));
    setAnim({running:true,steps,stepIdx:0,stepText:steps[0].text,total:steps.length});
    hlNode(steps[0].node);
    if(steps[0].mut) setState(s=>steps[0].mut(s));

    if(steps.length===1){
      setAnim(a=>({...a,running:false}));
      hlNode(null);
      return;
    }
    if(modeRef.current==='step') return; // Wait for manual advance

    // Auto mode
    let i=1;
    function next(){
      if(i>=steps.length){setAnim(a=>({...a,running:false,stepIdx:steps.length-1}));hlNode(null);return;}
      const step=steps[i];
      setAnim(a=>({...a,stepIdx:i,stepText:step.text}));
      hlNode(step.node);
      if(step.mut) setState(s=>step.mut(s));
      i++;
      tRef.current=setTimeout(next,step.delay||650);
    }
    tRef.current=setTimeout(next,steps[0].delay||650);
  },[]);

  const act = {
    draw:    useCallback(()=>run(seqDraw(ns(),sRef.current)),[run]),
    move:    useCallback(()=>run(seqMove(sRef.current)),[run]),
    del:     useCallback(()=>run(seqDelete(sRef.current)),[run]),
    dup:     useCallback(()=>run(seqDuplicate(sRef.current)),[run]),
    cancel:  useCallback(()=>run(seqCancel(sRef.current)),[run]),
    undo:    useCallback(()=>run(seqUndo(sRef.current)),[run]),
    redo:    useCallback(()=>run(seqRedo(sRef.current)),[run]),
    reset:   useCallback(()=>{
      if(tRef.current)clearTimeout(tRef.current);
      hlNode(null); si=0;
      setState(INIT);
      setAnim({running:false,steps:[],stepIdx:-1,stepText:'Reset! Click an action to start.',total:0});
    },[]),
  };

  const {running}=anim;
  const canU=state.undoStack.length>0, canR=state.redoStack.length>0, hasEl=state.elements>0;
  const hasSel=!!state.selectedLabel;
  const prog=anim.total>0?((anim.stepIdx+1)/anim.total)*100:0;
  const undoVis=state.undoStack.slice(-8).reverse();
  const redoVis=state.redoStack.slice(-8).reverse();
  const isStep=mode==='step';
  const showNext=isStep&&running;

  return h('div',{className:'flex flex-col h-full'},
    // Header bar
    h('div',{className:'flex items-center justify-between px-4 py-2.5 border-b border-wt-border/50 flex-shrink-0'},
      h('div',{className:'flex items-center gap-2'},
        h('div',{className:'w-2 h-2 rounded-full',style:{background:running?'#22c55e':'#a855f7'}}),
        h('span',{className:'text-[10px] font-semibold text-wt-fg tracking-wider uppercase'},'Simulator'),
        running && !isStep ? h('span',{className:'text-[9px] text-green-400 ml-1'},'PLAYING') : null,
        running && isStep ? h('span',{className:'text-[9px] text-emerald-300 ml-1'},'STEPPING') : null,
      ),
      h('div',{className:'flex items-center gap-2'},
        state.pendingCP ? h('span',{className:'text-[10px] text-yellow-400 cp-glow px-1.5 py-0.5 rounded border border-yellow-400/30'},'\u23F3 Checkpoint') : null,
        h('div',{className:'mode-seg'},
          h('button',{className:mode==='auto'?'active':'',disabled:running,onClick:()=>setMode('auto')},'Auto'),
          h('button',{className:mode==='step'?'active':'',disabled:running,onClick:()=>setMode('step')},'Step'),
        ),
      ),
    ),

    // Canvas state
    h('div',{className:'flex items-center justify-center gap-3 px-4 py-3 border-b border-wt-border/30 flex-shrink-0'},
      h('div',{className:'px-4 py-2 rounded-lg border transition-all duration-300 text-center flex-1',
        style:{borderColor:running?'#a855f7':'#2a2a2a', background:running?'rgba(168,85,247,0.05)':'rgba(20,20,20,0.4)'}
      },
        h('div',{className:'text-2xl font-bold text-wt-fg tabular-nums'},state.elements),
        h('div',{className:'text-[9px] text-wt-muted uppercase tracking-wider mt-0.5'},'Elements'),
      ),
      h('div',{className:'px-4 py-2 rounded-lg border transition-all duration-300 text-center flex-1',
        style:{borderColor:state.selectedLabel?'#a855f7':'#2a2a2a', background:state.selectedLabel?'rgba(168,85,247,0.05)':'rgba(20,20,20,0.4)'}
      },
        h('div',{className:'text-sm font-semibold text-wt-fg truncate',style:{minHeight:'1.75rem',lineHeight:'1.75rem'}},state.selectedLabel||'\u2014'),
        h('div',{className:'text-[9px] text-wt-muted uppercase tracking-wider mt-0.5'},'Selected'),
      ),
    ),

    // Stacks side-by-side
    h('div',{className:'flex gap-3 px-4 py-3 flex-1 min-h-0 overflow-hidden'},
      // Undo
      h('div',{className:'flex-1 flex flex-col min-w-0'},
        h('div',{className:'flex items-center gap-1 mb-1.5'},
          h('span',{className:'text-[9px] uppercase tracking-wider text-wt-muted font-semibold'},'Undo'),
          h('span',{className:'text-[9px] text-wt-accent tabular-nums'},`(${state.undoStack.length})`),
          state.undoStack.length>=MAX_SIM_HISTORY ? h('span',{className:'text-[9px] text-red-400/60'},'MAX') : null,
        ),
        h('div',{className:`flex flex-col gap-1 overflow-y-auto flex-1 ${state.capHit?'cap-flash':''}`,key:state.capHit?'f'+state.nid:'n'},
          undoVis.length===0
            ? h('div',{className:'text-[10px] text-wt-muted/40 italic text-center py-3'},'empty')
            : undoVis.map(e=>h(StackCard,{key:e.id,entry:e})),
          state.undoStack.length>8 ? h('div',{className:'text-[9px] text-wt-muted/30 text-center'},`+${state.undoStack.length-8} more`) : null,
        ),
      ),
      // Divider
      h('div',{className:'w-px bg-wt-border/40 self-stretch flex-shrink-0'}),
      // Redo
      h('div',{className:'flex-1 flex flex-col min-w-0'},
        h('div',{className:'flex items-center gap-1 mb-1.5'},
          h('span',{className:'text-[9px] uppercase tracking-wider text-wt-muted font-semibold'},'Redo'),
          h('span',{className:'text-[9px] text-wt-accent tabular-nums'},`(${state.redoStack.length})`),
        ),
        h('div',{className:'flex flex-col gap-1 overflow-y-auto flex-1'},
          redoVis.length===0
            ? h('div',{className:'text-[10px] text-wt-muted/40 italic text-center py-3'},'empty')
            : redoVis.map(e=>h(StackCard,{key:e.id,entry:e})),
          state.redoStack.length>8 ? h('div',{className:'text-[9px] text-wt-muted/30 text-center'},`+${state.redoStack.length-8} more`) : null,
        ),
      ),
    ),

    // Buttons
    h('div',{className:'flex flex-col gap-1.5 px-4 py-2.5 border-t border-wt-border/30 flex-shrink-0'},
      h('div',{className:'flex flex-wrap gap-1.5 justify-center'},
        h('button',{className:'sim-btn sim-btn-accent',onClick:act.draw,disabled:running},'\u25A1 Draw'),
        h('button',{className:'sim-btn',onClick:act.dup,disabled:running||!hasSel},'\u29C9 Dup'),
        h('button',{className:'sim-btn',onClick:act.move,disabled:running||!hasEl},'\u2725 Move'),
        h('button',{className:'sim-btn sim-btn-warn',onClick:act.del,disabled:running||!hasEl},'\u2717 Delete'),
        h('button',{className:'sim-btn',onClick:act.cancel,disabled:running||!hasEl},'\u238C Cancel'),
      ),
      h('div',{className:'flex flex-wrap gap-1.5 justify-center'},
        h('button',{className:'sim-btn',onClick:act.undo,disabled:running||!canU},'\u21A9 Undo'),
        h('button',{className:'sim-btn',onClick:act.redo,disabled:running||!canR},'\u21AA Redo'),
        h('button',{className:'sim-btn',onClick:act.reset,disabled:running,style:{opacity:0.5}},'Reset'),
      ),
    ),

    // Step narration
    h('div',{className:'px-4 py-2.5 border-t border-wt-border/50 flex-shrink-0'},
      h('div',{className:'progress-track mb-2'},
        h('div',{className:'progress-fill',style:{width:prog+'%'}}),
      ),
      h('div',{className:'flex items-center gap-2 min-h-[32px]'},
        anim.total>0
          ? h('span',{className:'text-[10px] text-wt-accent font-mono flex-shrink-0 tabular-nums'},
              `${Math.min(anim.stepIdx+1,anim.total)}/${anim.total}`)
          : null,
        h('p',{key:anim.stepIdx,className:'text-xs text-wt-muted step-anim leading-relaxed flex-1'},anim.stepText),
        showNext
          ? h('button',{className:'sim-btn sim-btn-next flex-shrink-0',onClick:advanceStep},'Next \u25B8')
          : null,
      ),
      showNext ? h('div',{className:'text-[9px] text-wt-muted/40 mt-1 text-right'},'Space / \u2192 to advance') : null,
    ),
  );
}

// ─── App ───
function App() {
  const [activeId, setActiveId] = useState(null);

  const onNodeClick = useCallback((nodeId) => {
    setActiveId(nodeId);
    document.querySelectorAll('.mermaid-wrap .node').forEach(n => {
      n.classList.remove('node-highlighted');
      n.style.opacity = nodeId ? '0.3' : '1';
    });
    if (nodeId) {
      const el = document.querySelector(`.mermaid-wrap .node[id*="${nodeId}"]`);
      if (el) el.style.opacity = '1';
    }
  }, []);

  const closeDetail = useCallback(() => {
    setActiveId(null);
    document.querySelectorAll('.mermaid-wrap .node').forEach(n => {
      n.classList.remove('node-highlighted');
      n.style.opacity = '1';
    });
  }, []);

  return h('div',{className:'flex h-screen w-screen'},

    // ── Left column: Diagram ──
    h('div',{className:'flex-1 flex flex-col min-w-0 border-r border-wt-border relative'},

      // Header
      h('div',{className:'px-6 py-4 border-b border-wt-border flex-shrink-0'},
        h('h1',{className:'text-base font-semibold text-wt-fg'},'History (Undo/Redo)'),
        h('p',{className:'text-sm text-wt-muted mt-0.5'},'How state snapshots, dual stacks, and checkpoints power undo/redo'),
      ),

      // Diagram — fills remaining space
      h('div',{className:'flex-1 overflow-auto p-4 flex items-start justify-center'},
        h(MermaidDiagram,{onNodeClick}),
      ),

      // Legend
      h('div',{className:'px-6 py-2 border-t border-wt-border/40 flex gap-4 flex-shrink-0 justify-center'},
        ...LEGEND.map(l=>
          h('span',{key:l.label,className:'flex items-center gap-1.5 text-[10px] text-wt-muted'},
            h('span',{className:`w-1.5 h-1.5 rounded-full ${l.color}`}),l.label)
        ),
        h('span',{className:'text-[10px] text-wt-muted/40 ml-4'},'Click nodes for details'),
      ),

      // Detail overlay (over diagram)
      activeId && NODES[activeId]
        ? h(DetailOverlay,{nodeId:activeId,node:NODES[activeId],onClose:closeDetail})
        : null,
    ),

    // ── Right column: Simulator ──
    h('div',{className:'flex flex-col flex-shrink-0',style:{width:'400px'}},
      h(Simulator),
    ),
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(h(App));
</script>
</body>
</html>

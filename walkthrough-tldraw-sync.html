<!DOCTYPE html>
<html lang="en" style="color-scheme:dark">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>tldraw Sync — How Multiplayer Works</title>
<script src="https://cdn.tailwindcss.com"></script>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
<script>
tailwind.config = {
  theme: {
    extend: {
      colors: {
        wt: {
          bg: "#000000", surface: "#0a0a0a", raised: "#141414",
          border: "#2a2a2a", fg: "#ffffff", muted: "#a0a0a0",
          accent: "#a855f7", file: "#c084fc", red: "#ef4444",
        },
        node: {
          component: "#a855f7", composable: "#7c3aed", utility: "#6d28d9",
          external: "#525252", event: "#d8b4fe", data: "#9333ea",
        },
      },
    },
  },
};
</script>
<style>
body { margin: 0; background: #000; overflow: hidden; }
.mermaid-wrap svg { max-width: none !important; height: auto !important; }
.mermaid-wrap .node { cursor: pointer; }
.mermaid-wrap .node:hover rect,
.mermaid-wrap .node:hover polygon,
.mermaid-wrap .node:hover circle,
.mermaid-wrap .node:hover .label-container { filter: brightness(1.3); transition: filter 0.15s; }
.mermaid-wrap .cluster-label { font-size: 14px !important; font-weight: 700 !important; letter-spacing: 0.05em !important; }
.mermaid-wrap .edgeLabel { font-size: 11px !important; }
.mermaid-wrap small { font-size: 10px; opacity: 0.7; }
.dt-body p { color: #a0a0a0; font-size: 0.88rem; line-height: 1.65; margin-bottom: 10px; }
.dt-body p code { background: rgba(168,85,247,0.12); padding: 1px 6px; border-radius: 4px; font-family: "SF Mono","Fira Code",monospace; font-size: 0.82rem; color: #c084fc; }
.dt-body .shiki { background: #000000 !important; border: 1px solid #2a2a2a; border-radius: 8px; padding: 14px 16px; overflow-x: auto; margin: 8px 0 14px; }
.dt-body .shiki code { font-family: "SF Mono","Fira Code",monospace; font-size: 0.78rem; line-height: 1.55; background: none; padding: 0; border-radius: 0; color: inherit; }
.dt-body pre.code-fallback { background: #000000; border: 1px solid #2a2a2a; border-radius: 8px; padding: 14px 16px; overflow-x: auto; margin: 8px 0 14px; }
.dt-body pre.code-fallback code { font-family: "SF Mono","Fira Code",monospace; font-size: 0.78rem; line-height: 1.55; color: #e0e0e0; background: none; padding: 0; border-radius: 0; }
</style>
</head>
<body class="bg-wt-bg text-wt-fg">
<div id="root"></div>
<script type="module">
import { createHighlighter } from 'https://cdn.jsdelivr.net/npm/shiki@3.22.0/+esm';

const { useState, useEffect, useRef, useCallback } = React;
const h = React.createElement;

const SUMMARY = "tldraw's sync uses a client-server model over WebSocket. Clients make optimistic local edits and push diffs to an authoritative server room, which validates changes, resolves conflicts (server wins), and broadcasts patches to all peers. A logical clock and tombstone system enable incremental sync and reliable reconnection — like git rebase, but for real-time drawing.";

const DIAGRAM = `graph TD
  userAction(["User draws, moves, or deletes"]):::event

  subgraph client["CLIENT — Optimistic Updates"]
    storeListener["Store Listener<br/><small>filters source: user, scope: document</small>"]:::event
    speculativeState[("Three-Tier<br/>Speculative State<br/><small>speculative · pending · unsent</small>")]:::data
    rebase(["Rebase Engine<br/><small>undo · apply server · re-apply local</small>"]):::composable
  end

  webSocket{{"WebSocket Adapter<br/><small>auto-reconnect · chunking · health check</small>"}}:::utility

  subgraph server["SERVER — Source of Truth"]
    syncRoom["Sync Room<br/><small>sessions · schema migration · presence</small>"]:::component
    conflictResolution{"Conflict Resolution<br/><small>server wins</small>"}:::composable
    broadcast(["Broadcast to Peers<br/><small>60fps debounced · per-session migration</small>"]):::composable
  end

  storage[("Storage + Clock<br/><small>documents · tombstones · metadata</small>")]:::external

  userAction ==>|"every edit"| storeListener
  storeListener ==>|"RecordsDiff  added · updated · removed"| speculativeState
  speculativeState ==>|"push message  (30fps throttled)"| webSocket
  webSocket ==>|"clientClock + NetworkDiff"| syncRoom
  syncRoom ==>|"validate + up-migrate schema"| conflictResolution
  conflictResolution ==>|"atomic transaction"| storage

  conflictResolution -.->|"push_result:  commit | rebaseWithDiff | discard"| webSocket
  syncRoom -->|"fan-out to other sessions"| broadcast
  broadcast -.->|"patch + serverClock  (down-migrated per client)"| webSocket

  webSocket -.->|"buffered server events"| rebase
  rebase -.->|"recalculate speculativeChanges"| speculativeState

  storage -.->|"getChangesSince(clock)  on reconnect"| syncRoom

  classDef component fill:#a855f7,stroke:#c084fc,color:#fff,font-weight:bold
  classDef composable fill:#7c3aed,stroke:#a78bfa,color:#fff
  classDef utility fill:#6d28d9,stroke:#8b5cf6,color:#fff
  classDef external fill:#525252,stroke:#737373,color:#fff
  classDef event fill:#d8b4fe,stroke:#e9d5ff,color:#000
  classDef data fill:#9333ea,stroke:#a855f7,color:#fff

  click storeListener nodeClickHandler "View details"
  click speculativeState nodeClickHandler "View details"
  click rebase nodeClickHandler "View details"
  click webSocket nodeClickHandler "View details"
  click syncRoom nodeClickHandler "View details"
  click conflictResolution nodeClickHandler "View details"
  click broadcast nodeClickHandler "View details"
  click storage nodeClickHandler "View details"
`;

const NODES = {
  storeListener: {
    title: "Store Listener",
    description: "The tldraw Store is the single source of truth on the client — it holds every record (shapes, pages, assets, etc.) as a flat map of ID to JSON object. The sync client registers a listener on this store that fires on every mutation.\n\nCritically, the listener filters for source: 'user' and scope: 'document'. This means it only captures changes the local user made to document records. It ignores: (1) remote changes applied by the sync system itself (source: 'remote'), which prevents infinite loops, (2) presence records like cursor position (scope: 'presence'), which flow through a separate channel, and (3) session-local state that shouldn't be synced.\n\nThe changes object is a RecordsDiff — a structured diff with three maps: added (new records), updated (before/after pairs), and removed (deleted records). This diff is passed directly to the push() method which feeds it into the speculative state system.",
    files: ["packages/sync-core/src/lib/TLSyncClient.ts"],
    code: `this.store.listen(\n  ({ changes }) => { this.push(changes) },\n  { source: 'user', scope: 'document' }\n)`,
    lang: "typescript",
  },
  speculativeState: {
    title: "Speculative State (Three-Tier Tracking)",
    description: "The heart of tldraw's optimistic update system. Think of it like git's three areas — working directory, staging, and committed-but-not-pushed.\n\nTier 1 — speculativeChanges (RecordsDiff): The complete accumulated diff of everything the user has changed locally that the server hasn't confirmed yet. This is the master record. If you reverse this diff and apply it to the current store, you get exactly what the server believes the state to be. Every local edit gets squashed into this via squashRecordDiffsMutable().\n\nTier 2 — pendingPushRequests (TLPushRequest[]): An ordered queue of push messages already sent over the WebSocket but not yet acknowledged by the server. Each carries a clientClock number. When the server responds with a push_result, the client shifts the first item off this queue and matches it by clientClock. If the result is 'commit', that push is confirmed. If 'rebaseWithDiff', the client needs to reconcile.\n\nTier 3 — unsentChanges ({ nextDiff?, nextPresence? }): A staging buffer for changes that haven't been sent yet. The push() method writes here, and a throttled sender (FPS-based, 30fps collaborative / 1fps solo) periodically drains it into a new push request. This batching prevents flooding the server with micro-updates — e.g., every pixel of a drag operation gets squashed into one push per frame.\n\nWhen the server acknowledges a push (commit), the corresponding pending request is removed. The speculative changes remain valid because they're a superset. When the server sends a patch from another client or a rebaseWithDiff, the rebase engine kicks in.",
    files: ["packages/sync-core/src/lib/TLSyncClient.ts"],
    code: `// Three tiers of local state:\nspeculativeChanges: RecordsDiff<R>  // all unconfirmed\npendingPushRequests: TLPushRequest[] // sent, awaiting ack\nunsentChanges: { nextDiff?, nextPresence? } // staging area`,
    lang: "typescript",
  },
  rebase: {
    title: "Rebase Engine",
    description: "The most complex part of the client. When the server sends events (patches from other users, or push_results for our own pushes), they go into an incomingDiffBuffer queue. A throttled scheduleRebase() then processes the entire buffer in one batch.\n\nHere's what happens during a rebase, step by step:\n\n1. UNDO — Reverse all speculative changes by applying reverseRecordsDiff(speculativeChanges) to the store with runCallbacks: false. The store now reflects the last known server state. This is wrapped in store.mergeRemoteChanges() so the store listener doesn't re-capture these as user changes.\n\n2. PROCESS SERVER EVENTS — Walk through each buffered event. For push_results: if 'commit', shift the pending request (it's confirmed). If 'rebaseWithDiff', apply the server's corrected diff and shift the pending request. If 'discard', drop the pending request entirely. For patches: apply the server's NetworkDiff to the store.\n\n3. RE-APPLY — After all server events are processed, re-apply the remaining pending push requests on top of the new server state. Use store.extractingChanges() to capture what actually changed — this becomes the new speculativeChanges. Some pending changes may now be no-ops (if the server already has that state), which is fine.\n\nConcrete example: You draw a rectangle while Alice moves a circle. Your rectangle push is in-flight. The server sends Alice's circle move as a patch. Rebase: undo your rectangle, apply Alice's circle move, re-draw your rectangle on top. Both edits coexist.\n\nThe rebase also uses value-based equality (not reference equality) when applying diffs. If the server sends a record that's identical in value to what's already in the store, no change is made — this prevents unnecessary Vue/React reactivity triggers.\n\nThrottling matters because rebases are expensive (undo + re-apply touches the entire store). In collaborative mode (30fps), rebases happen at most every 33ms. In solo mode (1fps), they're even rarer since there are no peer patches to process.",
    files: ["packages/sync-core/src/lib/TLSyncClient.ts"],
    code: `// 1. Undo all speculative changes\nstore.applyDiff(reverseRecordsDiff(this.speculativeChanges))\n// 2. Apply each server event (patches + push_results)\nfor (const event of this.incomingDiffBuffer) {\n  if (event.type === 'patch') this.applyNetworkDiff(event.diff)\n  // push_results: shift pending, apply rebase diffs\n}\n// 3. Re-apply remaining pending pushes\nthis.speculativeChanges = store.extractingChanges(() => {\n  for (const push of this.pendingPushRequests)\n    this.applyNetworkDiff(push.diff) // re-apply our changes\n})`,
    lang: "typescript",
  },
  webSocket: {
    title: "WebSocket Adapter + Message Protocol",
    description: "The transport layer: a robust WebSocket wrapper plus the wire protocol that defines what flows through it.\n\nThe 5 message types (protocol v8):\n1. CONNECT (handshake) — Client sends its schema + lastServerClock (0 for first visit). Server responds with a hydrationType ('wipe_all' = replace everything; 'wipe_presence' = keep docs, reset cursors), a NetworkDiff of all needed records, the current serverClock, and a readonly flag.\n2. PUSH (client to server) — Local changes as a NetworkDiff + optional presence (cursor, selection). Carries a monotonic clientClock for matching responses.\n3. PUSH_RESULT (server to client) — The verdict: 'commit' (accepted as-is), 'discard' (rejected, e.g. readonly), or { rebaseWithDiff } (conflict — here's the corrected state).\n4. PATCH (server to client) — Broadcast of another user's changes. Contains a NetworkDiff + new serverClock.\n5. PING/PONG — Heartbeat for health monitoring, no data payload.\n\nThe NetworkDiff format: A compact map of record ID to RecordOp. RecordOp is a tagged tuple: [0, fullRecord] for Put, [1, ObjectDiff] for Patch (granular field changes), [2] for Remove. ObjectDiff maps property names to ValueOp (Put/Delete/Append/Patch). The Append op is clever — it specifies an offset and new content, enabling concurrent text edits.\n\nReconnection: Uses a ReconnectManager with exponential backoff. Base delay 500ms, doubling each attempt. Maximum depends on tab visibility — 2 seconds active, up to 5 minutes backgrounded. Browser events ('online', 'visibilitychange', 'focus') trigger immediate reconnect attempts.\n\nChunking: Cloudflare Workers has a 1MB WebSocket limit. Large messages are split into ~250KB chunks prefixed with a counter: '2_<data>' means 2 more coming, '0_<data>' is the last. JsonChunkAssembler reassembles on the receiving end. Messages starting with '{' bypass chunking (fast path).\n\nInterface abstraction: TLSyncClient programs against TLPersistentClientSocket (connectionStatus, sendMessage, onReceiveMessage, restart, close). You could swap WebSocket for WebRTC or long-polling without changing sync logic.\n\nHealth monitoring: Pings every 10s. If 20s pass with no server response, the connection is assumed silently dead and resetConnection() forces a reconnect.",
    files: [
      "packages/sync-core/src/lib/ClientWebSocketAdapter.ts",
      "packages/sync-core/src/lib/chunk.ts",
      "packages/sync-core/src/lib/protocol.ts",
      "packages/sync-core/src/lib/diff.ts",
    ],
    code: `// Complete session lifecycle:\nClient -> { type: 'connect', schema, lastServerClock: 0 }\nServer -> { type: 'connect', diff, serverClock: 1, hydrationType: 'wipe_all' }\nClient -> { type: 'push', clientClock: 1, diff: myChanges }\nServer -> { type: 'push_result', clientClock: 1, action: 'commit' }\nServer -> { type: 'patch', diff: aliceChanges, serverClock: 42 }`,
    lang: "typescript",
  },
  syncRoom: {
    title: "Sync Room",
    description: "The authoritative server-side engine — one instance per document/room. It owns the canonical state and is the single arbiter of truth.\n\nSession lifecycle (state machine): When a WebSocket connects, TLSocketRoom.handleSocketConnect() creates a ServerSocketAdapter and calls TLSyncRoom.handleNewSession(). The session starts in 'awaiting-connect-message' with a 10s timeout — if the client doesn't send a connect message in time, it's kicked. Once the connect handshake completes, the session moves to 'connected'. Connected sessions track lastInteractionTime and have a debounceTimer for message batching. If a session goes idle for 20s, pruneSessions() (running every 2s) moves it to 'awaiting-removal' with a 5s grace period before final cleanup.\n\nSchema migration: Different clients might be running different versions of your app with different record schemas. The room stores the current server schema. When a client connects with an older schema, the room can down-migrate the diff it sends (converting newer record formats to older ones). When a client pushes changes from an older schema, the room up-migrates them before applying. If migration fails in either direction, the session is rejected with TLIncompatibilityReason.CLIENT_TOO_OLD.\n\nPresence: Cursor positions, selections, and user info are treated as ephemeral presence records. They're stored in a separate in-memory PresenceStore (not persisted to disk). When a session disconnects, its presence is immediately deleted and a removal patch is broadcast to all peers. Presence pushes bypass the full conflict resolution path — they're simpler put-or-patch operations.\n\nTwo-layer architecture: TLSyncRoom is the protocol engine (knows nothing about WebSockets). TLSocketRoom wraps it for WebSocket usage, adding per-session JsonChunkAssembler instances and handling the WebSocket message/close/error events. This separation lets you use TLSyncRoom with any transport.",
    files: [
      "packages/sync-core/src/lib/TLSyncRoom.ts",
      "packages/sync-core/src/lib/TLSocketRoom.ts",
      "packages/sync-core/src/lib/RoomSession.ts",
    ],
    code: `// Session state machine:\ntype RoomSession =\n  | { state: 'awaiting-connect-message', sessionStartTime } // 10s timeout\n  | { state: 'connected', lastInteractionTime, debounceTimer,\n      outstandingDataMessages: TLSocketServerSentEvent[] }\n  | { state: 'awaiting-removal', cancellationTime }  // 5s grace`,
    lang: "typescript",
  },
  conflictResolution: {
    title: "Conflict Resolution",
    description: "tldraw uses a 'server wins' conflict resolution strategy. Here's exactly how it works:\n\nWhen the server receives a push with a Patch operation (partial update) for a record, it doesn't blindly apply the client's diff. Instead, it calls applyAndDiffRecord(): (1) takes the current server-side record, (2) applies the client's ObjectDiff to it, (3) validates the result against the RecordType schema, (4) computes the actual diff between the old server state and the new state.\n\nThe key insight: if another client modified the same record between when this client last synced and now, the base state is different from what the client assumed. The applied result will be different from what the client intended.\n\nConcrete example: Suppose a rectangle has { x: 100, y: 200, width: 50 }. Alice moves it to x: 150 (pushes { x: [put, 150] }). Meanwhile Bob resizes it to width: 80 (pushes { width: [put, 80] }). If Alice's push arrives first, the server applies her x change. When Bob's push arrives, the server state is { x: 150, y: 200, width: 50 }. Bob's diff only touches width, so it applies cleanly to { x: 150, y: 200, width: 80 }. Both edits coexist — no conflict.\n\nBut if both Alice and Bob change x simultaneously: Alice to x: 150, Bob to x: 200. Alice's push arrives first → server state becomes x: 150. Bob's push arrives → server applies Bob's patch to get x: 200. The server sends Alice's change as a patch to Bob, and Bob's change as a rebaseWithDiff to... actually no — both get commit because they each modify x independently and the server just applies each in order. The last writer wins for the same field.\n\nFor Put operations (full record replacement), the server validates the record, stores it, and computes the diff from the old state. If the new record is identical to what's already stored, no broadcast happens.\n\nFor Remove operations, the server deletes the record and creates a tombstone. If the record doesn't exist, it's a no-op.\n\nValidation is strict: every mutated record is checked against its RecordType.validate(). If validation fails, the entire push for that record is rejected with a TLSyncError INVALID_RECORD, and the server sends back a rebaseWithDiff containing the record's current (valid) state so the client can correct itself.",
    files: [
      "packages/sync-core/src/lib/TLSyncRoom.ts",
      "packages/sync-core/src/lib/recordDiff.ts",
    ],
    code: `// Server applies client patch to current state:\nconst [newRecord, actualDiff] = applyAndDiffRecord(currentServerState, clientPatch)\n// actualDiff may differ from clientPatch if state diverged\n// If actualDiff === clientPatch → action: 'commit'\n// If actualDiff !== clientPatch → action: { rebaseWithDiff: actualDiff }\n// If validation fails → reject record, send current state back`,
    lang: "typescript",
  },
  broadcast: {
    title: "Broadcast to Peers",
    description: "After the server processes a push and applies changes, it needs to notify all other connected clients. This is the broadcast step.\n\nFor each connected session (excluding the one that sent the push), the server prepares a patch message. But there's a complication: different clients may be on different schema versions. Before sending, the server calls migrateDiffOrRejectSession() which down-migrates the diff from the server's schema version to each client's schema version. If a client is too old for migration to work, its session is rejected with CLIENT_TOO_OLD and it gets disconnected.\n\nDebouncing (60fps batching): Sending a separate WebSocket message for every single change would be wasteful — during rapid drawing, that could be hundreds of messages per second. Instead, the server uses a per-session debounce timer. When the first message in a batch arrives, it's sent immediately and a timer is set for 16.67ms (~60fps). Any subsequent messages during that window are queued in session.outstandingDataMessages[]. When the timer fires, _flushDataMessages() sends all queued messages as a single 'data' envelope: { type: 'data', data: [patch1, push_result2, patch3] }. The client unpacks this and processes each sub-message.\n\nPresence broadcasts work the same way but are slightly different in content — they contain cursor positions and selections. When a client disconnects, a special broadcast removes their presence record from all other clients, so cursors disappear immediately.\n\nThe broadcast also handles the push_result for the originating client. This is sent through the same debounced channel — so a client's push_result and other clients' patches can arrive in the same 'data' envelope.",
    files: ["packages/sync-core/src/lib/TLSyncRoom.ts"],
    code: `// Per-session debounced sending:\n_unsafe_sendMessage(sessionId, message) {\n  if (!session.debounceTimer) {\n    // First message: send immediately, start timer\n    socket.sendMessage({ type: 'data', data: [message] })\n    session.debounceTimer = setTimeout(\n      () => _flushDataMessages(sessionId), 16.67 // ~60fps\n    )\n  } else {\n    // Queue for next flush\n    session.outstandingDataMessages.push(message)\n  }\n}`,
    lang: "typescript",
  },
  storage: {
    title: "Storage + Clock",
    description: "The persistence layer that makes sync durable. It's pluggable — you pick the implementation, but all share the same TLSyncStorage interface built around transactional access.\n\nThe three SQLite tables:\n• documents (id TEXT PK, state BLOB, lastChangedClock INTEGER) — every record stored as a UTF-8 JSON blob with the clock value of when it was last modified. Indexed on lastChangedClock for fast range queries.\n• tombstones (id TEXT PK, clock INTEGER) — when a record is deleted, its ID and deletion clock are stored here instead of truly removing it. This lets the server tell reconnecting clients 'these records were deleted since you last synced'. Indexed on clock.\n• metadata (documentClock INTEGER, tombstoneHistoryStartsAtClock INTEGER, schema TEXT) — singleton row tracking the global clock, the oldest tombstone we still have, and the current schema version.\n\nThe documentClock: A monotonically increasing integer, incremented once per transaction (lazy — only incremented if the transaction actually modifies something). Every set() or delete() stamps the record/tombstone with the current clock. This creates a total ordering of all changes.\n\nIncremental sync via getChangesSince(clock): When a client reconnects with lastServerClock=42, the server queries documents WHERE lastChangedClock > 42 and tombstones WHERE clock > 42. This returns only what changed — no need to send the entire document state.\n\nTombstone pruning: Tombstones accumulate over time. When count exceeds MAX_TOMBSTONES (5000), the oldest TOMBSTONE_PRUNE_BUFFER_SIZE (1000) extra tombstones are deleted, and tombstoneHistoryStartsAtClock is updated to the clock of the oldest remaining tombstone. If a reconnecting client's lastServerClock is older than tombstoneHistoryStartsAtClock, we can't compute an accurate incremental diff (we don't know what was deleted). So wipeAll is set to true, forcing the client to throw away its local state and accept a full snapshot.\n\nThree implementations: SQLiteSyncStorage (production — works with Cloudflare Durable Objects SqlStorage or Node.js better-sqlite3/node:sqlite), InMemorySyncStorage (development — uses tldraw's reactive AtomMap, data lost on restart), and the wrappers DurableObjectSqliteSyncWrapper and NodeSqliteWrapper that adapt platform-specific SQLite APIs to a common TLSyncSqliteWrapper interface.\n\nExternal change detection: The storage emits onChange callbacks with a transaction ID. TLSyncRoom listens and compares the ID against its own internal transactions. If the ID doesn't match (meaning an external process wrote to the database), it calls broadcastExternalStorageChanges() to push those changes to all clients.",
    files: [
      "packages/sync-core/src/lib/TLSyncStorage.ts",
      "packages/sync-core/src/lib/SQLiteSyncStorage.ts",
      "packages/sync-core/src/lib/InMemorySyncStorage.ts",
    ],
    code: `-- SQLite schema (3 tables):\nCREATE TABLE documents (\n  id TEXT PRIMARY KEY,\n  state BLOB NOT NULL,          -- JSON-encoded record\n  lastChangedClock INTEGER NOT NULL\n);\nCREATE TABLE tombstones (\n  id TEXT PRIMARY KEY,\n  clock INTEGER NOT NULL         -- when deleted\n);\nCREATE TABLE metadata (\n  documentClock INTEGER NOT NULL,\n  tombstoneHistoryStartsAtClock INTEGER NOT NULL,\n  schema TEXT NOT NULL\n);`,
    lang: "sql",
  },
};

const LEGEND = [
  { label: "Entry / Trigger", color: "bg-node-event" },
  { label: "State", color: "bg-node-data" },
  { label: "Processing", color: "bg-node-composable" },
  { label: "Core Engine", color: "bg-node-component" },
  { label: "Transport", color: "bg-node-utility" },
  { label: "Persistence", color: "bg-[#525252]" },
  { label: "Push path", color: "bg-wt-fg" },
  { label: "Return path", color: "bg-wt-muted" },
];

// Shiki init
const langs = [...new Set(Object.values(NODES).map(n => n.lang).filter(Boolean))];
if (langs.length === 0) langs.push('typescript');
let highlighter = null;
try {
  highlighter = await createHighlighter({ themes: ['vitesse-dark'], langs });
} catch (e) {
  console.warn('Shiki failed to load:', e);
}
const HIGHLIGHTED = {};
for (const [id, node] of Object.entries(NODES)) {
  if (node.code && highlighter) {
    try {
      HIGHLIGHTED[id] = highlighter.codeToHtml(node.code, { lang: node.lang || 'typescript', theme: 'vitesse-dark' });
    } catch (e) { console.warn(`Highlight failed for ${id}:`, e); }
  }
}

// --- React Components (createElement, no JSX) ---

function usePanZoom() {
  const viewportRef = useRef(null);
  const canvasRef = useRef(null);
  const zoomDisplayRef = useRef(null);
  const st = useRef({ zoom: 1, panX: 0, panY: 0 });
  const drag = useRef({ on: false, lx: 0, ly: 0 });

  const apply = useCallback(() => {
    const { zoom, panX, panY } = st.current;
    if (canvasRef.current) canvasRef.current.style.transform = `translate(${panX}px,${panY}px) scale(${zoom})`;
    if (zoomDisplayRef.current) zoomDisplayRef.current.textContent = Math.round(zoom * 100) + '%';
  }, []);

  const fitToScreen = useCallback(() => {
    const svg = canvasRef.current?.querySelector('svg');
    const vp = viewportRef.current;
    if (!svg || !vp) return;
    const s = st.current;
    const vw = vp.clientWidth, vh = vp.clientHeight;
    const sw = svg.getBoundingClientRect().width / s.zoom;
    const sh = svg.getBoundingClientRect().height / s.zoom;
    const fit = Math.max(0.15, Math.min(2, Math.min((vw - 80) / sw, (vh - 80) / sh)));
    s.zoom = fit;
    s.panX = (vw - sw * fit) / 2;
    s.panY = (vh - sh * fit) / 2;
    apply();
  }, [apply]);

  useEffect(() => {
    const vp = viewportRef.current;
    if (!vp) return;
    const onWheel = (e) => {
      e.preventDefault();
      const r = vp.getBoundingClientRect();
      const mx = e.clientX - r.left, my = e.clientY - r.top;
      const s = st.current;
      const f = e.deltaY < 0 ? 1.12 : 1 / 1.12;
      const nz = Math.min(4, Math.max(0.15, s.zoom * f));
      const sc = nz / s.zoom;
      s.panX = mx - sc * (mx - s.panX);
      s.panY = my - sc * (my - s.panY);
      s.zoom = nz;
      apply();
    };
    const onDown = (e) => {
      if (e.target.closest('.node')) return;
      drag.current = { on: true, lx: e.clientX, ly: e.clientY };
      vp.setPointerCapture(e.pointerId);
    };
    const onMove = (e) => {
      const d = drag.current;
      if (!d.on) return;
      st.current.panX += e.clientX - d.lx;
      st.current.panY += e.clientY - d.ly;
      d.lx = e.clientX;
      d.ly = e.clientY;
      apply();
    };
    const onUp = () => { drag.current.on = false; };
    vp.addEventListener('wheel', onWheel, { passive: false });
    vp.addEventListener('pointerdown', onDown);
    vp.addEventListener('pointermove', onMove);
    vp.addEventListener('pointerup', onUp);
    vp.addEventListener('pointercancel', onUp);
    window.addEventListener('resize', fitToScreen);
    return () => {
      vp.removeEventListener('wheel', onWheel);
      vp.removeEventListener('pointerdown', onDown);
      vp.removeEventListener('pointermove', onMove);
      vp.removeEventListener('pointerup', onUp);
      vp.removeEventListener('pointercancel', onUp);
      window.removeEventListener('resize', fitToScreen);
    };
  }, [apply, fitToScreen]);

  const zoomIn = useCallback(() => { st.current.zoom = Math.min(4, st.current.zoom * 1.25); apply(); }, [apply]);
  const zoomOut = useCallback(() => { st.current.zoom = Math.max(0.15, st.current.zoom / 1.25); apply(); }, [apply]);

  return { viewportRef, canvasRef, zoomDisplayRef, zoomIn, zoomOut, fitToScreen };
}

function MermaidDiagram({ onNodeClick }) {
  const ref = useRef(null);
  useEffect(() => {
    window.nodeClickHandler = onNodeClick;
    mermaid.initialize({
      startOnLoad: false, theme: 'dark',
      themeVariables: {
        primaryColor: '#0a0a0a', primaryTextColor: '#ffffff', primaryBorderColor: '#2a2a2a',
        lineColor: '#a0a0a0', secondaryColor: '#000000', tertiaryColor: '#000000',
        background: '#000000', mainBkg: '#0a0a0a', nodeBorder: '#2a2a2a',
        clusterBkg: 'rgba(10,10,10,0.8)', clusterBorder: '#7c3aed',
        titleColor: '#ffffff', edgeLabelBackground: 'transparent',
      },
      flowchart: { useMaxWidth: false, htmlLabels: true, curve: 'basis' },
      securityLevel: 'loose',
    });
    mermaid.render('walkthrough-diagram', DIAGRAM).then(({ svg, bindFunctions }) => {
      if (ref.current) {
        ref.current.innerHTML = svg;
        bindFunctions?.(ref.current);
      }
    });
    return () => { delete window.nodeClickHandler; };
  }, [onNodeClick]);
  return h('div', { ref, className: 'mermaid-wrap' });
}

function Summary() {
  return h('div', {
    className: 'fixed top-16 left-6 z-10 max-w-lg px-4 py-3 bg-wt-surface/80 backdrop-blur border border-wt-border rounded-lg shadow-lg pointer-events-none'
  }, h('p', { className: 'text-sm text-wt-muted leading-relaxed' }, SUMMARY));
}

function DetailPanel({ nodeId, node, onClose }) {
  useEffect(() => {
    const onKey = (e) => { if (e.key === 'Escape') onClose(); };
    document.addEventListener('keydown', onKey);
    return () => document.removeEventListener('keydown', onKey);
  }, [onClose]);

  const codeHtml = HIGHLIGHTED[nodeId];

  return h('div', {
    className: 'fixed top-4 right-4 bottom-4 w-[640px] z-30 bg-wt-surface border border-wt-border rounded-xl shadow-2xl flex flex-col overflow-hidden'
  },
    h('button', {
      onClick: onClose,
      className: 'absolute top-3 right-3 z-10 w-7 h-7 rounded-md border border-wt-border bg-wt-raised text-wt-muted flex items-center justify-center text-lg hover:bg-wt-red hover:border-wt-red hover:text-white transition-colors'
    }, '\u00d7'),
    h('div', { className: 'flex-1 overflow-y-auto p-5' },
      h('h2', { className: 'text-lg font-bold text-wt-fg mb-3 pr-9' }, node.title),
      h('div', { className: 'dt-body' },
        ...node.description.split('\n\n').map((para, i) => h('p', { key: 'p' + i }, para))
      ),
      node.code ? h('div', { className: 'dt-body' },
        codeHtml
          ? h('div', { dangerouslySetInnerHTML: { __html: codeHtml } })
          : h('pre', { className: 'code-fallback' }, h('code', null, node.code))
      ) : null,
      node.files && node.files.length > 0
        ? h('div', { className: 'mt-4 pt-3 border-t border-wt-border' },
            h('div', { className: 'text-[0.7rem] uppercase tracking-wider text-wt-muted font-semibold mb-1.5' }, 'Files'),
            h('code', { className: 'text-sm text-wt-file font-mono leading-relaxed' },
              node.files.map((f, i) => h('span', { key: i }, f, h('br')))
            )
          )
        : null
    )
  );
}

function ZoomControls({ zoomDisplayRef, onZoomIn, onZoomOut, onFit }) {
  const btnCls = 'w-8 h-8 rounded-md border border-wt-border bg-wt-raised text-wt-muted flex items-center justify-center hover:bg-wt-accent hover:border-wt-accent hover:text-white transition-colors text-sm';
  return h('div', { className: 'fixed bottom-5 left-5 z-20 flex items-center gap-1.5 px-2 py-1.5 bg-wt-surface border border-wt-border rounded-lg shadow-xl' },
    h('button', { onClick: onZoomOut, className: btnCls }, '\u2212'),
    h('span', { ref: zoomDisplayRef, className: 'text-xs text-wt-muted w-12 text-center tabular-nums' }, '100%'),
    h('button', { onClick: onZoomIn, className: btnCls }, '+'),
    h('button', { onClick: onFit, className: btnCls, title: 'Fit to screen' }, '\u2922')
  );
}

function App() {
  const [activeId, _setActiveId] = useState(null);
  const pz = usePanZoom();

  const setActiveNode = useCallback((nodeId) => {
    _setActiveId(nodeId);
    document.querySelectorAll('.mermaid-wrap .node').forEach(n => {
      n.style.opacity = nodeId ? '0.4' : '1';
    });
    if (nodeId) {
      const el = document.querySelector(`.mermaid-wrap .node[id*="${nodeId}"]`);
      if (el) el.style.opacity = '1';
    }
  }, []);

  const closeDetail = useCallback(() => {
    _setActiveId(null);
    document.querySelectorAll('.mermaid-wrap .node').forEach(n => { n.style.opacity = '1'; });
  }, []);

  useEffect(() => { setTimeout(pz.fitToScreen, 600); }, [pz.fitToScreen]);

  return h(React.Fragment, null,
    h('header', { className: 'fixed top-0 inset-x-0 z-10 px-6 py-3.5 bg-gradient-to-b from-wt-bg to-transparent pointer-events-none' },
      h('h1', { className: 'text-base font-semibold text-wt-fg' }, 'tldraw Sync Architecture'),
      h('p', { className: 'text-sm text-wt-muted mt-0.5' }, 'How real-time multiplayer collaboration works under the hood')
    ),
    h(Summary),
    h('div', { ref: pz.viewportRef, className: 'w-full h-screen overflow-hidden cursor-grab active:cursor-grabbing' },
      h('div', { ref: pz.canvasRef, className: 'origin-top-left will-change-transform inline-block p-[80px_60px_60px]' },
        h(MermaidDiagram, { onNodeClick: setActiveNode })
      )
    ),
    h(ZoomControls, { zoomDisplayRef: pz.zoomDisplayRef, onZoomIn: pz.zoomIn, onZoomOut: pz.zoomOut, onFit: pz.fitToScreen }),
    h('div', { className: 'fixed bottom-5 left-1/2 -translate-x-1/2 z-20 flex gap-4 px-4 py-2 bg-wt-surface border border-wt-border rounded-lg shadow-xl' },
      LEGEND.map(l => h('span', { key: l.label, className: 'flex items-center gap-1.5 text-xs text-wt-muted' },
        h('span', { className: `w-2 h-2 rounded-full ${l.color}` }), l.label
      ))
    ),
    activeId && NODES[activeId] ? h(DetailPanel, { nodeId: activeId, node: NODES[activeId], onClose: closeDetail }) : null,
    h('div', { className: 'fixed bottom-5 right-5 z-20 text-xs text-wt-muted opacity-50' },
      h('kbd', null, 'Scroll'), ' zoom \u00b7 ', h('kbd', null, 'Drag'), ' pan \u00b7 Click nodes'
    )
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(h(App));
</script>
</body>
</html>
